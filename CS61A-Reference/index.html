

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <!--LXGW font-->
  <link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont/style.css" media="print" onload="this.media='all'">
  <!---->
  <!-- webspider -->
  <meta name="baidu-site-verification" content="codeva-GNK5uXsCLO" />
  <meta name="google-site-verification" content="7Mq8zQQEoIxqxJvemX8hlZtErGSJtATFN9SegHGJ2eg" />
  <!-- --- -->
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon1.png">
  <link rel="icon" href="/img/favicon1.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#414643">
  <meta name="author" content="Konrad Gerrens">
  <meta name="keywords" content="">
  
    <meta name="description" content="Composing Programs by John DeNero, based on the textbook Structure and Interpretation of Computer Programs by Harold Abelson and Gerald Jay Sussman.">
<meta property="og:type" content="article">
<meta property="og:title" content="CS61A-Reference">
<meta property="og:url" content="https://www.0co.dev/CS61A-Reference/">
<meta property="og:site_name" content="Ethereal State">
<meta property="og:description" content="Composing Programs by John DeNero, based on the textbook Structure and Interpretation of Computer Programs by Harold Abelson and Gerald Jay Sussman.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307091514452.png">
<meta property="article:published_time" content="2023-07-19T09:18:41.000Z">
<meta property="article:modified_time" content="2023-10-31T03:06:19.000Z">
<meta property="article:author" content="Konrad Gerrens">
<meta property="article:tag" content="CS61A">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307091514452.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>CS61A-Reference - Ethereal State</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"www.0co.dev","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":60,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  



  
<meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="Ethereal State" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Ethereal State</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="CS61A-Reference"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-07-19 17:18" pubdate>
          2023年7月19日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          95k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          795 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">CS61A-Reference</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2023年10月31日 上午
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <div class="note note-success">
            <p>Composing Programs by <u><a target="_blank" rel="noopener" href="http://www.denero.org/">John DeNero</a></u>, based on the textbook <u><a target="_blank" rel="noopener" href="http://mitpress.mit.edu/sicp/">Structure and Interpretation of Computer Programs</a></u> by Harold Abelson and Gerald Jay Sussman, is licensed under a <u><a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 Unported License</a></u>.</p>
          </div>

<h1 id="Chapter-1-Building-Abstractions-with-Functions"><a href="#Chapter-1-Building-Abstractions-with-Functions" class="headerlink" title="Chapter 1: Building Abstractions with Functions"></a>Chapter 1: Building Abstractions with Functions</h1><h2 id="1-1-Getting-Started"><a href="#1-1-Getting-Started" class="headerlink" title="1.1  Getting Started"></a>1.1  Getting Started</h2><p>Computer science is a tremendously broad academic discipline. The areas of globally distributed systems, artificial intelligence, robotics, graphics, security, scientific computing, computer architecture, and dozens of emerging sub-fields all expand with new techniques and discoveries every year. The rapid progress of computer science has left few aspects of human life unaffected. Commerce, communication, science, art, leisure, and politics have all been reinvented as computational domains.</p>
<p>The high productivity of computer science is only possible because the discipline is built upon an elegant and powerful set of fundamental ideas. All computing begins with representing information, specifying logic to process it, and designing abstractions that manage the complexity of that logic. Mastering these fundamentals will require us to understand precisely how computers interpret computer programs and carry out computational processes.</p>
<p>These fundamental ideas have long been taught using the classic textbook <em>Structure and Interpretation of Computer Programs</em> (<a target="_blank" rel="noopener" href="http://mitpress.mit.edu/sicp">SICP</a>) by Harold Abelson and Gerald Jay Sussman with Julie Sussman. This text borrows heavily from that textbook, which the original authors have kindly licensed for adaptation and reuse under a Creative Commons license. These notes are published under the <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US">Creative Commons attribution non-commericial share-alike license version 3</a>.</p>
<h3 id="1-1-1-Programming-in-Python"><a href="#1-1-1-Programming-in-Python" class="headerlink" title="1.1.1  Programming in Python"></a>1.1.1  Programming in Python</h3><blockquote>
<p>A language isn’t something you learn so much as something you join.</p>
<p>—<a target="_blank" rel="noopener" href="http://arikaokrent.com/">Arika Okrent</a></p>
</blockquote>
<p>In order to define computational processes, we need a programming language; preferably one that many humans and a great variety of computers can all understand. In this text, we will work primarily with the <a target="_blank" rel="noopener" href="http://docs.python.org/py3k/">Python</a> language.</p>
<p>Python is a widely used programming language that has recruited enthusiasts from many professions: web programmers, game engineers, scientists, academics, and even designers of new programming languages. When you learn Python, you join a million-person-strong community of developers. Developer communities are tremendously important institutions: members help each other solve problems, share their projects and experiences, and collectively develop software and tools. Dedicated members often achieve celebrity and widespread esteem for their contributions.</p>
<p>The Python language itself is the product of a <a target="_blank" rel="noopener" href="http://www.python.org/psf/members/">large volunteer community</a> that prides itself on the <a target="_blank" rel="noopener" href="http://python.org/community/diversity/">diversity</a> of its contributors. The language was conceived and first implemented by <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Guido_van_Rossum">Guido van Rossum</a> in the late 1980’s. The first chapter of his <a target="_blank" rel="noopener" href="http://docs.python.org/py3k/tutorial/appetite.html">Python 3 Tutorial</a> explains why Python is so popular, among the many languages available today.</p>
<p>Python excels as an instructional language because, throughout its history, Python’s developers have emphasized the human interpretability of Python code, reinforced by the <a target="_blank" rel="noopener" href="http://www.python.org/dev/peps/pep-0020/">Zen of Python</a> guiding principles of beauty, simplicity, and readability. Python is particularly appropriate for this text because its broad set of features support a variety of different programming styles, which we will explore. While there is no single way to program in Python, there are a set of conventions shared across the developer community that facilitate reading, understanding, and extending existing programs. Python’s combination of great flexibility and accessibility allows students to explore many programming paradigms, and then apply their newly acquired knowledge to thousands of <a target="_blank" rel="noopener" href="http://pypi.python.org/pypi">ongoing projects</a>.</p>
<p>These notes maintain the spirit of <a target="_blank" rel="noopener" href="http://mitpress.mit.edu/sicp">SICP</a> by introducing the features of Python in step with techniques for abstraction and a rigorous model of computation. In addition, these notes provide a practical introduction to Python programming, including some advanced language features and illustrative examples. Increasing your facility with Python should come naturally as you progress through the text.</p>
<p>The best way to get started programming in Python is to interact with the interpreter directly. This section describes how to install Python 3, initiate an interactive session with the interpreter, and start programming.</p>
<h3 id="1-1-2-Installing-Python-3"><a href="#1-1-2-Installing-Python-3" class="headerlink" title="1.1.2  Installing Python 3"></a>1.1.2  Installing Python 3</h3><p>As with all great software, Python has many versions. This text will use the most recent stable version of Python 3. Many computers have older versions of Python installed already, such as Python 2.7, but those will not match the descriptions in this text. You should be able to use any computer, but expect to install Python 3. (Don’t worry, Python is free.)</p>
<p>You can download Python 3 from the Python downloads page by clicking on the version that begins with 3 (not 2). Follow the instructions of the installer to complete installation.</p>
<p>For further guidance, try these video tutorials on <a target="_blank" rel="noopener" href="http://www.youtube.com/watch?v=54-wuFsPi0w">Windows installation</a> and <a target="_blank" rel="noopener" href="http://www.youtube.com/watch?v=smHuBHxJdK8">Mac installation</a> of Python 3, created by Julia Oh.</p>
<h3 id="1-1-3-Interactive-Sessions"><a href="#1-1-3-Interactive-Sessions" class="headerlink" title="1.1.3  Interactive Sessions"></a>1.1.3  Interactive Sessions</h3><p>In an interactive Python session, you type some Python <em>code</em> after the <em>prompt</em>, <code>&gt;&gt;&gt;</code>. The Python <em>interpreter</em> reads and executes what you type, carrying out your various commands.</p>
<p>To start an interactive session, run the Python 3 application. Type <code>python3</code> at a terminal prompt (Mac&#x2F;Unix&#x2F;Linux) or open the Python 3 application in Windows.</p>
<p>If you see the Python prompt, <code>&gt;&gt;&gt;</code>, then you have successfully started an interactive session. These notes depict example interactions using the prompt, followed by some input.</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">2</span> + <span class="hljs-number">2</span></span><br>4<br></code></pre></td></tr></table></figure>

<p><strong>Interactive controls.</strong> Each session keeps a history of what you have typed. To access that history, press <code>&lt;Control&gt;-P</code> (previous) and <code>&lt;Control&gt;-N</code> (next). <code>&lt;Control&gt;-D</code> exits a session, which discards this history. Up and down arrows also cycle through history on some systems.</p>
<h3 id="1-1-4-First-Example"><a href="#1-1-4-First-Example" class="headerlink" title="1.1.4  First Example"></a>1.1.4  First Example</h3><blockquote>
<p>And, as imagination bodies forth</p>
<p>The forms of things to unknown, and the poet’s pen</p>
<p>Turns them to shapes, and gives to airy nothing</p>
<p>A local habitation and a name.</p>
<p>—William Shakespeare, A Midsummer-Night’s Dream</p>
</blockquote>
<p>To give Python a proper introduction, we will begin with an example that uses several language features. In the next section, we will start from scratch and build up the language piece by piece. Think of this section as a sneak preview of features to come.</p>
<p>Python has built-in support for a wide range of common programming activities, such as manipulating text, displaying graphics, and communicating over the Internet. The line of Python code</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">from</span> urllib.request <span class="hljs-keyword">import</span> urlopen</span><br></code></pre></td></tr></table></figure>

<p>is an <code>import</code> statement that loads functionality for accessing data on the Internet. In particular, it makes available a function called <code>urlopen</code>, which can access the content at a uniform resource locator (URL), a location of something on the Internet.</p>
<p><strong>Statements &amp; Expressions</strong>. Python code consists of expressions and statements. Broadly, computer programs consist of instructions to either</p>
<ol>
<li>Compute some value</li>
<li>Carry out some action</li>
</ol>
<p>Statements typically describe actions. When the Python interpreter executes a statement, it carries out the corresponding action. On the other hand, expressions typically describe computations. When Python evaluates an expression, it computes the value of that expression. This chapter introduces several types of statements and expressions.</p>
<p>The assignment statement</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl">&gt;&gt;&gt; <span class="hljs-variable">shakespeare</span> = <span class="hljs-function"><span class="hljs-title">urlopen</span>(<span class="hljs-string">&#x27;http://composingprograms.com/shakespeare.txt&#x27;</span>)</span><br></code></pre></td></tr></table></figure>

<p>associates the name <code>shakespeare</code> with the value of the expression that follows <code>=</code>. That expression applies the <code>urlopen</code> function to a URL that contains the complete text of William Shakespeare’s 37 plays, all in a single text document.</p>
<p><strong>Functions</strong>. Functions encapsulate logic that manipulates data. <code>urlopen</code> is a function. A web address is a piece of data, and the text of Shakespeare’s plays is another. The process by which the former leads to the latter may be complex, but we can apply that process using only a simple expression because that complexity is tucked away within a function. Functions are the primary topic of this chapter.</p>
<p>Another assignment statement</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">&gt;&gt;&gt; words = set(<span class="hljs-name">shakespeare</span>.read().decode().split())<br></code></pre></td></tr></table></figure>

<p>associates the name <code>words</code> to the set of all unique words that appear in Shakespeare’s plays, all 33,721 of them. The chain of commands to <code>read</code>, <code>decode</code>, and <code>split</code>, each operate on an intermediate computational entity: we <code>read</code> the data from the opened URL, then <code>decode</code> the data into text, and finally <code>split</code> the text into words. All of those words are placed in a <code>set</code>.</p>
<p><strong>Objects</strong>. A <code>set</code> is a type of object, one that supports set operations like computing intersections and membership. An object seamlessly bundles together data and the logic that manipulates that data, in a way that manages the complexity of both. Objects are the primary topic of Chapter 2. Finally, the expression</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&gt;&gt;&gt; &#123;w for w in words if len(w) == <span class="hljs-number">6</span> and w[::-<span class="hljs-number">1</span>] in words&#125;<br>&#123;<span class="hljs-string">&#x27;redder&#x27;</span>, <span class="hljs-string">&#x27;drawer&#x27;</span>, <span class="hljs-string">&#x27;reward&#x27;</span>, <span class="hljs-string">&#x27;diaper&#x27;</span>, <span class="hljs-string">&#x27;repaid&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>

<p>is a compound expression that evaluates to the set of all Shakespearian words that are simultaneously a word spelled in reverse. The cryptic notation <code>w[::-1]</code> enumerates each letter in a word, but the <code>-1</code> dictates to step backwards. When you enter an expression in an interactive session, Python prints its value on the following line.</p>
<p><strong>Interpreters</strong>. Evaluating compound expressions requires a precise procedure that interprets code in a predictable way. A program that implements such a procedure, evaluating compound expressions, is called an interpreter. The design and implementation of interpreters is the primary topic of Chapter 3.</p>
<p>When compared with other computer programs, interpreters for programming languages are unique in their generality. Python was not designed with Shakespeare in mind. However, its great flexibility allowed us to process a large amount of text with only a few statements and expressions.</p>
<p>In the end, we will find that all of these core concepts are closely related: functions are objects, objects are functions, and interpreters are instances of both. However, developing a clear understanding of each of these concepts and their role in organizing code is critical to mastering the art of programming.</p>
<h3 id="1-1-5-Errors"><a href="#1-1-5-Errors" class="headerlink" title="1.1.5  Errors"></a>1.1.5  Errors</h3><p>Python is waiting for your command. You are encouraged to experiment with the language, even though you may not yet know its full vocabulary and structure. However, be prepared for errors. While computers are tremendously fast and flexible, they are also extremely rigid. The nature of computers is described in <a target="_blank" rel="noopener" href="http://web.stanford.edu/class/cs101/code-1-introduction.html">Stanford’s introductory course</a> as</p>
<blockquote>
<p>The fundamental equation of computers is:</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">computer</span> = powerful + stupid<br></code></pre></td></tr></table></figure>

<p>Computers are very powerful, looking at volumes of data very quickly. Computers can perform billions of operations per second, where each operation is pretty simple.</p>
<p>Computers are also shockingly stupid and fragile. The operations that they can do are extremely rigid, simple, and mechanical. The computer lacks anything like real insight … it’s nothing like the HAL 9000 from the movies. If nothing else, you should not be intimidated by the computer as if it’s some sort of brain. It’s very mechanical underneath it all.</p>
<p>Programming is about a person using their real insight to build something useful, constructed out of these teeny, simple little operations that the computer can do.</p>
<p>—Francisco Cai and Nick Parlante, Stanford CS101</p>
</blockquote>
<p>The rigidity of computers will immediately become apparent as you experiment with the Python interpreter: even the smallest spelling and formatting changes will cause unexpected output and errors.</p>
<p>Learning to interpret errors and diagnose the cause of unexpected errors is called <em>debugging</em>. Some guiding principles of debugging are:</p>
<ol>
<li><strong>Test incrementally</strong>: Every well-written program is composed of small, modular components that can be tested individually. Try out everything you write as soon as possible to identify problems early and gain confidence in your components.</li>
<li><strong>Isolate errors</strong>: An error in the output of a statement can typically be attributed to a particular modular component. When trying to diagnose a problem, trace the error to the smallest fragment of code you can before trying to correct it.</li>
<li><strong>Check your assumptions</strong>: Interpreters do carry out your instructions to the letter — no more and no less. Their output is unexpected when the behavior of some code does not match what the programmer believes (or assumes) that behavior to be. Know your assumptions, then focus your debugging effort on verifying that your assumptions actually hold.</li>
<li><strong>Consult others</strong>: You are not alone! If you don’t understand an error message, ask a friend, instructor, or search engine. If you have isolated an error, but can’t figure out how to correct it, ask someone else to take a look. A lot of valuable programming knowledge is shared in the process of group problem solving.</li>
</ol>
<p>Incremental testing, modular design, precise assumptions, and teamwork are themes that persist throughout this text. Hopefully, they will also persist throughout your computer science career.</p>
<h2 id="1-2-Elements-of-Programming"><a href="#1-2-Elements-of-Programming" class="headerlink" title="1.2  Elements of Programming"></a>1.2  Elements of Programming</h2><p>A programming language is more than just a means for instructing a computer to perform tasks. The language also serves as a framework within which we organize our ideas about computational processes. Programs serve to communicate those ideas among the members of a programming community. Thus, programs must be written for people to read, and only incidentally for machines to execute.</p>
<p>When we describe a language, we should pay particular attention to the means that the language provides for combining simple ideas to form more complex ideas. Every powerful language has three such mechanisms:</p>
<ul>
<li><strong>primitive expressions and statements</strong>, which represent the simplest building blocks that the language provides,</li>
<li><strong>means of combination</strong>, by which compound elements are built from simpler ones, and</li>
<li><strong>means of abstraction</strong>, by which compound elements can be named and manipulated as units.</li>
</ul>
<p>In programming, we deal with two kinds of elements: functions and data. (Soon we will discover that they are really not so distinct.) Informally, data is stuff that we want to manipulate, and functions describe the rules for manipulating the data. Thus, any powerful programming language should be able to describe primitive data and primitive functions, as well as have some methods for combining and abstracting both functions and data.</p>
<h3 id="1-2-1-Expressions"><a href="#1-2-1-Expressions" class="headerlink" title="1.2.1  Expressions"></a>1.2.1  Expressions</h3><p>Having experimented with the full Python interpreter in the previous section, we now start anew, methodically developing the Python language element by element. Be patient if the examples seem simplistic — more exciting material is soon to come.</p>
<p>We begin with primitive expressions. One kind of primitive expression is a number. More precisely, the expression that you type consists of the numerals that represent the number in base 10.</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">42</span></span><br>42<br></code></pre></td></tr></table></figure>

<p>Expressions representing numbers may be combined with mathematical operators to form a compound expression, which the interpreter will evaluate:</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">-<span class="hljs-number">1</span> - -<span class="hljs-number">1</span></span><br>0<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">1</span>/<span class="hljs-number">2</span> + <span class="hljs-number">1</span>/<span class="hljs-number">4</span> + <span class="hljs-number">1</span>/<span class="hljs-number">8</span> + <span class="hljs-number">1</span>/<span class="hljs-number">16</span> + <span class="hljs-number">1</span>/<span class="hljs-number">32</span> + <span class="hljs-number">1</span>/<span class="hljs-number">64</span> + <span class="hljs-number">1</span>/<span class="hljs-number">128</span></span><br>0.9921875<br></code></pre></td></tr></table></figure>

<p>These mathematical expressions use <em>infix</em> notation, where the <em>operator</em> (e.g., <code>+</code>, <code>-</code>, <code>*</code>, or <code>/</code>) appears in between the <em>operands</em> (numbers). Python includes many ways to form compound expressions. Rather than attempt to enumerate them all immediately, we will introduce new expression forms as we go, along with the language features that they support.</p>
<h3 id="1-2-2-Call-Expressions"><a href="#1-2-2-Call-Expressions" class="headerlink" title="1.2.2  Call Expressions"></a>1.2.2  Call Expressions</h3><p>The most important kind of compound expression is a <em>call expression</em>, which applies a function to some arguments. Recall from algebra that the mathematical notion of a function is a mapping from some input arguments to an output value. For instance, the <code>max</code> function maps its inputs to a single output, which is the largest of the inputs. The way in which Python expresses function application is the same as in conventional mathematics.</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">max</span>(<span class="hljs-number">7.5</span>, <span class="hljs-number">9.5</span>)</span><br>9.5<br></code></pre></td></tr></table></figure>

<p>This call expression has subexpressions: the <em>operator</em> is an expression that precedes parentheses, which enclose a comma-delimited list of <em>operand</em> expressions.</p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191721562.png" srcset="/img/loading.gif" lazyload></p>
<p>The operator specifies a <em>function</em>. When this call expression is evaluated, we say that the function <code>max</code> is <em>called</em> with <em>arguments</em> 7.5 and 9.5, and <em>returns</em> a <em>value</em> of 9.5.</p>
<p>The order of the arguments in a call expression matters. For instance, the function <code>pow</code> raises its first argument to the power of its second argument.</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">pow</span>(<span class="hljs-number">100</span>, <span class="hljs-number">2</span>)</span><br>10000<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">100</span>)</span><br>1267650600228229401496703205376<br></code></pre></td></tr></table></figure>

<p>Function notation has three principal advantages over the mathematical convention of infix notation. First, functions may take an arbitrary number of arguments:</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">4</span>)</span><br>3<br></code></pre></td></tr></table></figure>

<p>No ambiguity can arise, because the function name always precedes its arguments.</p>
<p>Second, function notation extends in a straightforward way to <em>nested</em> expressions, where the elements are themselves compound expressions. In nested call expressions, unlike compound infix expressions, the structure of the nesting is entirely explicit in the parentheses.</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">max</span>(<span class="hljs-built_in">min</span>(<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>), <span class="hljs-built_in">min</span>(<span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>), -<span class="hljs-number">4</span>))</span><br>-2<br></code></pre></td></tr></table></figure>

<p>There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the Python interpreter can evaluate. However, humans quickly get confused by multi-level nesting. An important role for you as a programmer is to structure expressions so that they remain interpretable by yourself, your programming partners, and other people who may read your expressions in the future.</p>
<p>Third, mathematical notation has a great variety of forms: multiplication appears between terms, exponents appear as superscripts, division as a horizontal bar, and a square root as a roof with slanted siding. Some of this notation is very hard to type! However, all of this complexity can be unified via the notation of call expressions. While Python supports common mathematical operators using infix notation (like <code>+</code> and <code>-</code>), any operator can be expressed as a function with a name.</p>
<h3 id="1-2-3-Importing-Library-Functions"><a href="#1-2-3-Importing-Library-Functions" class="headerlink" title="1.2.3  Importing Library Functions"></a>1.2.3  Importing Library Functions</h3><p>Python defines a very large number of functions, including the operator functions mentioned in the preceding section, but does not make all of their names available by default. Instead, it organizes the functions and other quantities that it knows about into modules, which together comprise the Python Library. To use these elements, one imports them. For example, the <code>math</code> module provides a variety of familiar mathematical functions:</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">sqrt(<span class="hljs-number">256</span>)</span><br>16.0<br></code></pre></td></tr></table></figure>

<p>and the <code>operator</code> module provides access to functions corresponding to infix operators:</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> add, sub, mul</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">add(<span class="hljs-number">14</span>, <span class="hljs-number">28</span>)</span><br>42<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">sub(<span class="hljs-number">100</span>, mul(<span class="hljs-number">7</span>, add(<span class="hljs-number">8</span>, <span class="hljs-number">4</span>)))</span><br>16<br></code></pre></td></tr></table></figure>

<p>An <code>import</code> statement designates a module name (e.g., <code>operator</code> or <code>math</code>), and then lists the named attributes of that module to import (e.g., <code>sqrt</code>). Once a function is imported, it can be called multiple times.</p>
<p>There is no difference between using these operator functions (e.g., <code>add</code>) and the operator symbols themselves (e.g., <code>+</code>). Conventionally, most programmers use symbols and infix notation to express simple arithmetic.</p>
<p>The <a target="_blank" rel="noopener" href="http://docs.python.org/py3k/library/index.html">Python 3 Library Docs</a> list the functions defined by each module, such as the <a target="_blank" rel="noopener" href="http://docs.python.org/py3k/library/math.html">math module</a>. However, this documentation is written for developers who know the whole language well. For now, you may find that experimenting with a function tells you more about its behavior than reading the documentation. As you become familiar with the Python language and vocabulary, this documentation will become a valuable reference source.</p>
<h3 id="1-2-4-Names-and-the-Environment"><a href="#1-2-4-Names-and-the-Environment" class="headerlink" title="1.2.4  Names and the Environment"></a>1.2.4  Names and the Environment</h3><p>A critical aspect of a programming language is the means it provides for using names to refer to computational objects. If a value has been given a name, we say that the name <em>binds</em> to the value.</p>
<p>In Python, we can establish new bindings using the assignment statement, which contains a name to the left of <code>=</code> and a value to the right:</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">radius = <span class="hljs-number">10</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">radius</span><br>10<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">2</span> * radius</span><br>20<br></code></pre></td></tr></table></figure>

<p>Names are also bound via <code>import</code> statements.</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> pi</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">pi * <span class="hljs-number">71</span> / <span class="hljs-number">223</span></span><br>1.0002380197528042<br></code></pre></td></tr></table></figure>

<p>The <code>=</code> symbol is called the <em>assignment</em> operator in Python (and many other languages). Assignment is our simplest means of <em>abstraction</em>, for it allows us to use simple names to refer to the results of compound operations, such as the <code>area</code> computed above. In this way, complex programs are constructed by building, step by step, computational objects of increasing complexity.</p>
<p>The possibility of binding names to values and later retrieving those values by name means that the interpreter must maintain some sort of memory that keeps track of the names, values, and bindings. This memory is called an <em>environment</em>.</p>
<p>Names can also be bound to functions. For instance, the name <code>max</code> is bound to the max function we have been using. Functions, unlike numbers, are tricky to render as text, so Python prints an identifying description instead, when asked to describe a function:</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fortran">&gt;&gt;&gt; <span class="hljs-built_in">max</span><br>&lt;built-<span class="hljs-keyword">in</span> <span class="hljs-function"><span class="hljs-keyword">function</span></span> <span class="hljs-built_in">max</span>&gt;<br></code></pre></td></tr></table></figure>

<p>We can use assignment statements to give new names to existing functions.</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">f = <span class="hljs-built_in">max</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">f</span><br>&lt;built-in function max&gt;<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">f(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span><br>4<br></code></pre></td></tr></table></figure>

<p>And successive assignment statements can rebind a name to a new value.</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">f = <span class="hljs-number">2</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">f</span><br>2<br></code></pre></td></tr></table></figure>

<p>In Python, names are often called <em>variable names</em> or <em>variables</em> because they can be bound to different values in the course of executing a program. When a name is bound to a new value through assignment, it is no longer bound to any previous value. One can even bind built-in names to new values.</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">max</span> = <span class="hljs-number">5</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">max</span></span><br>5<br></code></pre></td></tr></table></figure>

<p>After assigning <code>max</code> to 5, the name <code>max</code> is no longer bound to a function, and so attempting to call <code>max(2, 3, 4)</code> will cause an error.</p>
<p>When executing an assignment statement, Python evaluates the expression to the right of <code>=</code> before changing the binding to the name on the left. Therefore, one can refer to a name in right-side expression, even if it is the name to be bound by the assignment statement.</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">x = <span class="hljs-number">2</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">x = x + <span class="hljs-number">1</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">x</span><br>3<br></code></pre></td></tr></table></figure>

<p>We can also assign multiple values to multiple names in a single statement, where names on the left of <code>=</code> and expressions on the right of <code>=</code> are separated by commas.</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">area, circumference = pi * radius * radius, <span class="hljs-number">2</span> * pi * radius</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">area</span><br>314.1592653589793<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">circumference</span><br>62.83185307179586<br></code></pre></td></tr></table></figure>

<p>Changing the value of one name does not affect other names. Below, even though the name <code>area</code> was bound to a value defined originally in terms of <code>radius</code>, the value of <code>area</code> has not changed. Updating the value of <code>area</code> requires another assignment statement.</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">radius = <span class="hljs-number">11</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">area</span><br>314.1592653589793<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">area = pi * radius * radius</span><br>380.132711084365<br></code></pre></td></tr></table></figure>

<p>With multiple assignment, <em>all</em> expressions to the right of <code>=</code> are evaluated before <em>any</em> names to the left are bound to those values. As a result of this rule, swapping the values bound to two names can be performed in a single statement.</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">x, y = <span class="hljs-number">3</span>, <span class="hljs-number">4.5</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">y, x = x, y</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">x</span><br>4.5<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">y</span><br>3<br></code></pre></td></tr></table></figure>

<h3 id="1-2-5-Evaluating-Nested-Expressions"><a href="#1-2-5-Evaluating-Nested-Expressions" class="headerlink" title="1.2.5  Evaluating Nested Expressions"></a>1.2.5  Evaluating Nested Expressions</h3><p>One of our goals in this chapter is to isolate issues about thinking procedurally. As a case in point, let us consider that, in evaluating nested call expressions, the interpreter is itself following a procedure.</p>
<p>To evaluate a call expression, Python will do the following:</p>
<ol>
<li>Evaluate the operator and operand subexpressions, then</li>
<li>Apply the function that is the value of the operator subexpression to the arguments that are the values of the operand subexpressions.</li>
</ol>
<p>Even this simple procedure illustrates some important points about processes in general. The first step dictates that in order to accomplish the evaluation process for a call expression we must first evaluate other expressions. Thus, the evaluation procedure is <em>recursive</em> in nature; that is, it includes, as one of its steps, the need to invoke the rule itself.</p>
<p>For example, evaluating</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lisp">&gt;&gt;&gt; sub(<span class="hljs-name">pow</span>(<span class="hljs-number">2</span>, add(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)), pow(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>))<br><span class="hljs-number">2016</span><br></code></pre></td></tr></table></figure>

<p>requires that this evaluation procedure be applied four times. If we draw each expression that we evaluate, we can visualize the hierarchical structure of this process.</p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191722041.png" srcset="/img/loading.gif" lazyload></p>
<p>This illustration is called an <em>expression tree</em>. In computer science, trees conventionally grow from the top down. The objects at each point in a tree are called nodes; in this case, they are expressions paired with their values.</p>
<p>Evaluating its root, the full expression at the top, requires first evaluating the branches that are its subexpressions. The leaf expressions (that is, nodes with no branches stemming from them) represent either functions or numbers. The interior nodes have two parts: the call expression to which our evaluation rule is applied, and the result of that expression. Viewing evaluation in terms of this tree, we can imagine that the values of the operands percolate upward, starting from the terminal nodes and then combining at higher and higher levels.</p>
<p>Next, observe that the repeated application of the first step brings us to the point where we need to evaluate, not call expressions, but primitive expressions such as numerals (e.g., 2) and names (e.g., <code>add</code>). We take care of the primitive cases by stipulating that</p>
<ul>
<li>A numeral evaluates to the number it names,</li>
<li>A name evaluates to the value associated with that name in the current environment.</li>
</ul>
<p>Notice the important role of an environment in determining the meaning of the symbols in expressions. In Python, it is meaningless to speak of the value of an expression such as</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">&gt;&gt;&gt; <span class="hljs-keyword">add</span>(<span class="hljs-keyword">x</span><span class="hljs-punctuation">,</span> <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>

<p>without specifying any information about the environment that would provide a meaning for the name <code>x</code> (or even for the name <code>add</code>). Environments provide the context in which evaluation takes place, which plays an important role in our understanding of program execution.</p>
<p>This evaluation procedure does not suffice to evaluate all Python code, only call expressions, numerals, and names. For instance, it does not handle assignment statements. Executing</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">x = <span class="hljs-number">3</span></span><br></code></pre></td></tr></table></figure>

<p>does not return a value nor evaluate a function on some arguments, since the purpose of assignment is instead to bind a name to a value. In general, statements are not evaluated but <em>executed</em>; they do not produce a value but instead make some change. Each type of expression or statement has its own evaluation or execution procedure.</p>
<p>A pedantic note: when we say that “a numeral evaluates to a number,” we actually mean that the Python interpreter evaluates a numeral to a number. It is the interpreter which endows meaning to the programming language. Given that the interpreter is a fixed program that always behaves consistently, we can say that numerals (and expressions) themselves evaluate to values in the context of Python programs.</p>
<h3 id="1-2-6-The-Non-Pure-Print-Function"><a href="#1-2-6-The-Non-Pure-Print-Function" class="headerlink" title="1.2.6  The Non-Pure Print Function"></a>1.2.6  The Non-Pure Print Function</h3><p>Throughout this text, we will distinguish between two types of functions.</p>
<p><strong>Pure functions.</strong> Functions have some input (their arguments) and return some output (the result of applying them). The built-in function</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">abs</span>(-<span class="hljs-number">2</span>)</span><br>2<br></code></pre></td></tr></table></figure>

<p>can be depicted as a small machine that takes input and produces output.</p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191722109.png" srcset="/img/loading.gif" lazyload></p>
<p>The function <code>abs</code> is <em>pure</em>. Pure functions have the property that applying them has no effects beyond returning a value. Moreover, a pure function must always return the same value when called twice with the same arguments.</p>
<p><strong>Non-pure functions.</strong> In addition to returning a value, applying a non-pure function can generate <em>side effects</em>, which make some change to the state of the interpreter or computer. A common side effect is to generate additional output beyond the return value, using the <code>print</code> function.</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span><br>1 2 3<br></code></pre></td></tr></table></figure>

<p>While <code>print</code> and <code>abs</code> may appear to be similar in these examples, they work in fundamentally different ways. The value that <code>print</code> returns is always <code>None</code>, a special Python value that represents nothing. The interactive Python interpreter does not automatically print the value <code>None</code>. In the case of <code>print</code>, the function itself is printing output as a side effect of being called.</p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191723757.png" srcset="/img/loading.gif" lazyload></p>
<p>A nested expression of calls to <code>print</code> highlights the non-pure character of the function.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">print</span>(<span class="hljs-number">2</span>))<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-literal">None</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure>

<p>If you find this output to be unexpected, draw an expression tree to clarify why evaluating this expression produces this peculiar output.</p>
<p>Be careful with <code>print</code>! The fact that it returns <code>None</code> means that it <em>should not</em> be the expression in an assignment statement.</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">two = <span class="hljs-built_in">print</span>(<span class="hljs-number">2</span>)</span><br>2<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(two)</span><br>None<br></code></pre></td></tr></table></figure>

<p>Pure functions are restricted in that they cannot have side effects or change behavior over time. Imposing these restrictions yields substantial benefits. First, pure functions can be composed more reliably into compound call expressions. We can see in the non-pure function example above that <code>print</code> does not return a useful result when used in an operand expression. On the other hand, we have seen that functions such as <code>max</code>, <code>pow</code> and <code>sqrt</code> can be used effectively in nested expressions.</p>
<p>Second, pure functions tend to be simpler to test. A list of arguments will always lead to the same return value, which can be compared to the expected return value. Testing is discussed in more detail later in this chapter.</p>
<p>Third, Chapter 4 will illustrate that pure functions are essential for writing <em>concurrent</em> programs, in which multiple call expressions may be evaluated simultaneously.</p>
<p>By contrast, Chapter 2 investigates a range of non-pure functions and describes their uses.</p>
<p>For these reasons, we concentrate heavily on creating and using pure functions in the remainder of this chapter. The <code>print</code> function is only used so that we can see the intermediate results of computations.</p>
<h2 id="1-3-Defining-New-Functions"><a href="#1-3-Defining-New-Functions" class="headerlink" title="1.3  Defining New Functions"></a>1.3  Defining New Functions</h2><p>We have identified in Python some of the elements that must appear in any powerful programming language:</p>
<ol>
<li>Numbers and arithmetic operations are <em>primitive</em> built-in data values and functions.</li>
<li>Nested function application provides a means of <em>combining</em> operations.</li>
<li>Binding names to values provides a limited means of <em>abstraction</em>.</li>
</ol>
<p>Now we will learn about <em>function definitions</em>, a much more powerful abstraction technique by which a name can be bound to compound operation, which can then be referred to as a unit.</p>
<p>We begin by examining how to express the idea of <em>squaring</em>. We might say, “To square something, multiply it by itself.” This is expressed in Python as</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">&gt;&gt;&gt; def square(<span class="hljs-keyword">x</span>):<br>        return <span class="hljs-keyword">mul</span>(<span class="hljs-keyword">x</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">x</span>)<br></code></pre></td></tr></table></figure>

<p>which defines a new function that has been given the name <code>square</code>. This user-defined function is not built into the interpreter. It represents the compound operation of multiplying something by itself. The <code>x</code> in this definition is called a <em>formal parameter</em>, which provides a name for the thing to be multiplied. The definition creates this user-defined function and associates it with the name <code>square</code>.</p>
<p><strong>How to define a function.</strong> Function definitions consist of a <code>def</code> statement that indicates a <code>&lt;name&gt;</code> and a comma-separated list of named <code>&lt;formal parameters&gt;</code>, then a <code>return</code> statement, called the function body, that specifies the <code>&lt;return expression&gt;</code> of the function, which is an expression to be evaluated whenever the function is applied:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">def &lt;name&gt;(&lt;formal parameters&gt;):<br>    <span class="hljs-keyword">return</span> &lt;<span class="hljs-keyword">return</span> expression&gt;<br></code></pre></td></tr></table></figure>

<p>The second line <em>must</em> be indented — most programmers use four spaces to indent. The return expression is not evaluated right away; it is stored as part of the newly defined function and evaluated only when the function is eventually applied.</p>
<p>Having defined <code>square</code>, we can apply it with a call expression:</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">square(<span class="hljs-number">21</span>)</span><br>441<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">square(add(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>))</span><br>49<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">square(square(<span class="hljs-number">3</span>))</span><br>81<br></code></pre></td></tr></table></figure>

<p>We can also use <code>square</code> as a building block in defining other functions. For example, we can easily define a function <code>sum_squares</code> that, given any two numbers as arguments, returns the sum of their squares:</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum_squares</span>(<span class="hljs-params">x, y</span>):</span><br>        return add(square(x), square(y))<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">sum_squares(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span><br>25<br></code></pre></td></tr></table></figure>

<p>User-defined functions are used in exactly the same way as built-in functions. Indeed, one cannot tell from the definition of <code>sum_squares</code> whether <code>square</code> is built into the interpreter, imported from a module, or defined by the user.</p>
<p>Both <code>def</code> statements and assignment statements bind names to values, and any existing bindings are lost. For example, <code>g</code> below first refers to a function of no arguments, then a number, and then a different function of two arguments.</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">g</span>():</span><br>        return 1<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">g()</span><br>1<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">g = <span class="hljs-number">2</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">g</span><br>2<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">g</span>(<span class="hljs-params">h, i</span>):</span><br>        return h + i<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">g(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span><br>3<br></code></pre></td></tr></table></figure>

<h3 id="1-3-1-Environments"><a href="#1-3-1-Environments" class="headerlink" title="1.3.1  Environments"></a>1.3.1  Environments</h3><p>Our subset of Python is now complex enough that the meaning of programs is non-obvious. What if a formal parameter has the same name as a built-in function? Can two functions share names without confusion? To resolve such questions, we must describe environments in more detail.</p>
<p>An environment in which an expression is evaluated consists of a sequence of <em>frames</em>, depicted as boxes. Each frame contains <em>bindings</em>, each of which associates a name with its corresponding value. There is a single <em>global</em> frame. Assignment and import statements add entries to the first frame of the current environment. So far, our environment consists only of the global frame.</p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191735278.png" srcset="/img/loading.gif" lazyload></p>
<p>This <em>environment diagram</em> shows the bindings of the current environment, along with the values to which names are bound. The environment diagrams in this text are interactive: you can step through the lines of the small program on the left to see the state of the environment evolve on the right. You can also click on the “Edit code in Online Python Tutor” link to load the example into the <a target="_blank" rel="noopener" href="http://composingprograms.com/tutor.html">Online Python Tutor</a>, a tool created by <a target="_blank" rel="noopener" href="http://www.pgbovine.net/">Philip Guo</a> for generating these environment diagrams. You are encouraged to create examples yourself and study the resulting environment diagrams.</p>
<p>Functions appear in environment diagrams as well. An <code>import</code> statement binds a name to a built-in function. A <code>def</code> statement binds a name to a user-defined function created by the definition. The resulting environment after importing <code>mul</code> and defining <code>square</code> appears below:</p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191755574.png" srcset="/img/loading.gif" lazyload></p>
<p>Each function is a line that starts with <code>func</code>, followed by the function name and formal parameters. Built-in functions such as <code>mul</code> do not have formal parameter names, and so <code>...</code> is always used instead.</p>
<p>The name of a function is repeated twice, once in the frame and again as part of the function itself. The name appearing in the function is called the <em>intrinsic name</em>. The name in a frame is a <em>bound name</em>. There is a difference between the two: different names may refer to the same function, but that function itself has only one intrinsic name.</p>
<p>The name bound to a function in a frame is the one used during evaluation. The intrinsic name of a function does not play a role in evaluation. Step through the example below using the <em>Forward</em> button to see that once the name <code>max</code> is bound to the value 3, it can no longer be used as a function.</p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191809648.png" srcset="/img/loading.gif" lazyload></p>
<p>The error message <code>TypeError: &#39;int&#39; object is not callable</code> is reporting that the name <code>max</code> (currently bound to the number 3) is an integer and not a function. Therefore, it cannot be used as the operator in a call expression.</p>
<p><strong>Function Signatures.</strong> Functions differ in the number of arguments that they are allowed to take. To track these requirements, we draw each function in a way that shows the function name and its formal parameters. The user-defined function <code>square</code> takes only <code>x</code>; providing more or fewer arguments will result in an error. A description of the formal parameters of a function is called the function’s signature.</p>
<p>The function <code>max</code> can take an arbitrary number of arguments. It is rendered as <code>max(...)</code>. Regardless of the number of arguments taken, all built-in functions will be rendered as <code>&lt;name&gt;(...)</code>, because these primitive functions were never explicitly defined.</p>
<h3 id="1-3-2-Calling-User-Defined-Functions"><a href="#1-3-2-Calling-User-Defined-Functions" class="headerlink" title="1.3.2  Calling User-Defined Functions"></a>1.3.2  Calling User-Defined Functions</h3><p>To evaluate a call expression whose operator names a user-defined function, the Python interpreter follows a computational process. As with any call expression, the interpreter evaluates the operator and operand expressions, and then applies the named function to the resulting arguments.</p>
<p>Applying a user-defined function introduces a second <em>local</em> frame, which is only accessible to that function. To apply a user-defined function to some arguments:</p>
<ol>
<li>Bind the arguments to the names of the function’s formal parameters in a new <em>local</em> frame.</li>
<li>Execute the body of the function in the environment that starts with this frame.</li>
</ol>
<p>The environment in which the body is evaluated consists of two frames: first the local frame that contains formal parameter bindings, then the global frame that contains everything else. Each instance of a function application has its own independent local frame.</p>
<p>To illustrate an example in detail, several steps of the environment diagram for the same example are depicted below. After executing the first import statement, only the name <code>mul</code> is bound in the global frame.</p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191809993.png" srcset="/img/loading.gif" lazyload></p>
<p>First, the definition statement for the function <code>square</code> is executed. Notice that the entire <code>def</code> statement is processed in a single step. The body of a function is not executed until the function is called (not when it is defined).</p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191809942.png" srcset="/img/loading.gif" lazyload></p>
<p>Next, The <code>square</code> function is called with the argument <code>-2</code>, and so a new frame is created with the formal parameter <code>x</code> bound to the value <code>-2</code>.</p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191810817.png" srcset="/img/loading.gif" lazyload></p>
<p>Then, the name <code>x</code> is looked up in the current environment, which consists of the two frames shown. In both occurrences, <code>x</code> evaluates to <code>-2</code>, and so the <code>square</code> function returns 4.</p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191810068.png" srcset="/img/loading.gif" lazyload></p>
<p>The “Return value” in the <code>square()</code> frame is not a name binding; instead it indicates the value returned by the function call that created the frame.</p>
<p>Even in this simple example, two different environments are used. The top-level expression <code>square(-2)</code> is evaluated in the global environment, while the return expression <code>mul(x, x)</code> is evaluated in the environment created for by calling <code>square</code>. Both <code>x</code> and <code>mul</code> are bound in this environment, but in different frames.</p>
<p>The order of frames in an environment affects the value returned by looking up a name in an expression. We stated previously that a name is evaluated to the value associated with that name in the current environment. We can now be more precise:</p>
<p><strong>Name Evaluation.</strong> A name evaluates to the value bound to that name in the earliest frame of the current environment in which that name is found.</p>
<p>Our conceptual framework of environments, names, and functions constitutes a <em>model of evaluation</em>; while some mechanical details are still unspecified (e.g., how a binding is implemented), our model does precisely and correctly describe how the interpreter evaluates call expressions. In Chapter 3 we will see how this model can serve as a blueprint for implementing a working interpreter for a programming language.</p>
<h3 id="1-3-3-Example-Calling-a-User-Defined-Function"><a href="#1-3-3-Example-Calling-a-User-Defined-Function" class="headerlink" title="1.3.3  Example: Calling a User-Defined Function"></a>1.3.3  Example: Calling a User-Defined Function</h3><p>Let us again consider our two simple function definitions and illustrate the process that evaluates a call expression for a user-defined function.</p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191811298.png" srcset="/img/loading.gif" lazyload></p>
<p>Python first evaluates the name <code>sum_squares</code>, which is bound to a user-defined function in the global frame. The primitive numeric expressions 5 and 12 evaluate to the numbers they represent.</p>
<p>Next, Python applies <code>sum_squares</code>, which introduces a local frame that binds x to 5 and y to 12.</p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191811729.png" srcset="/img/loading.gif" lazyload></p>
<p>The body of <code>sum_squares</code> contains this call expression:</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">  add     (  square(x)  ,  square(y)  )<br><span class="hljs-strong">____</span><span class="hljs-strong">____</span>     <span class="hljs-strong">____</span><span class="hljs-strong">____</span>_     <span class="hljs-strong">____</span><span class="hljs-strong">____</span>_<br>operator     operand 0     operand 1<br></code></pre></td></tr></table></figure>

<p>All three subexpressions are evaluated in the current environment, which begins with the frame labeled <code>sum_squares()</code>. The operator subexpression <code>add</code> is a name found in the global frame, bound to the built-in function for addition. The two operand subexpressions must be evaluated in turn, before addition is applied. Both operands are evaluated in the current environment beginning with the frame labeled <code>sum_squares</code>.</p>
<p>In <code>operand 0</code>, <code>square</code> names a user-defined function in the global frame, while <code>x</code> names the number 5 in the local frame. Python applies <code>square</code> to 5 by introducing yet another local frame that binds x to 5.</p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191812314.png" srcset="/img/loading.gif" lazyload></p>
<p>Using this environment, the expression <code>mul(x, x)</code> evaluates to 25.</p>
<p>Our evaluation procedure now turns to <code>operand 1</code>, for which <code>y</code> names the number 12. Python evaluates the body of <code>square</code> again, this time introducing yet another local frame that binds <code>x</code> to 12. Hence, <code>operand 1</code> evaluates to 144.</p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191812403.png" srcset="/img/loading.gif" lazyload></p>
<p>Finally, applying addition to the arguments 25 and 144 yields a final return value for <code>sum_squares</code>: 169.</p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191812870.png" srcset="/img/loading.gif" lazyload></p>
<p>This example illustrates many of the fundamental ideas we have developed so far. Names are bound to values, which are distributed across many independent local frames, along with a single global frame that contains shared names. A new local frame is introduced every time a function is called, even if the same function is called twice.</p>
<p>All of this machinery exists to ensure that names resolve to the correct values at the correct times during program execution. This example illustrates why our model requires the complexity that we have introduced. All three local frames contain a binding for the name <code>x</code>, but that name is bound to different values in different frames. Local frames keep these names separate.</p>
<h3 id="1-3-4-Local-Names"><a href="#1-3-4-Local-Names" class="headerlink" title="1.3.4  Local Names"></a>1.3.4  Local Names</h3><p>One detail of a function’s implementation that should not affect the function’s behavior is the implementer’s choice of names for the function’s formal parameters. Thus, the following functions should provide the same behavior:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">square</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">return</span> mul(x, x)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">square</span>(<span class="hljs-params">y</span>):<br>        <span class="hljs-keyword">return</span> mul(y, y)<br></code></pre></td></tr></table></figure>

<p>This principle – that the meaning of a function should be independent of the parameter names chosen by its author – has important consequences for programming languages. The simplest consequence is that the parameter names of a function must remain local to the body of the function.</p>
<p>If the parameters were not local to the bodies of their respective functions, then the parameter <code>x</code> in <code>square</code> could be confused with the parameter <code>x</code> in <code>sum_squares</code>. Critically, this is not the case: the binding for <code>x</code> in different local frames are unrelated. The model of computation is carefully designed to ensure this independence.</p>
<p>We say that the <em>scope</em> of a local name is limited to the body of the user-defined function that defines it. When a name is no longer accessible, it is out of scope. This scoping behavior isn’t a new fact about our model; it is a consequence of the way environments work.</p>
<h3 id="1-3-5-Choosing-Names"><a href="#1-3-5-Choosing-Names" class="headerlink" title="1.3.5  Choosing Names"></a>1.3.5  Choosing Names</h3><p>The interchangeability of names does not imply that formal parameter names do not matter at all. On the contrary, well-chosen function and parameter names are essential for the human interpretability of function definitions!</p>
<p>The following guidelines are adapted from the <a target="_blank" rel="noopener" href="http://www.python.org/dev/peps/pep-0008">style guide for Python code</a>, which serves as a guide for all (non-rebellious) Python programmers. A shared set of conventions smooths communication among members of a developer community. As a side effect of following these conventions, you will find that your code becomes more internally consistent.</p>
<ol>
<li>Function names are lowercase, with words separated by underscores. Descriptive names are encouraged.</li>
<li>Function names typically evoke operations applied to arguments by the interpreter (e.g., <code>print</code>, <code>add</code>, <code>square</code>) or the name of the quantity that results (e.g., <code>max</code>, <code>abs</code>, <code>sum</code>).</li>
<li>Parameter names are lowercase, with words separated by underscores. Single-word names are preferred.</li>
<li>Parameter names should evoke the role of the parameter in the function, not just the kind of argument that is allowed.</li>
<li>Single letter parameter names are acceptable when their role is obvious, but avoid “l” (lowercase ell), “O” (capital oh), or “I” (capital i) to avoid confusion with numerals.</li>
</ol>
<p>There are many exceptions to these guidelines, even in the Python standard library. Like the vocabulary of the English language, Python has inherited words from a variety of contributors, and the result is not always consistent.</p>
<h3 id="1-3-6-Functions-as-Abstractions"><a href="#1-3-6-Functions-as-Abstractions" class="headerlink" title="1.3.6  Functions as Abstractions"></a>1.3.6  Functions as Abstractions</h3><p>Though it is very simple, <code>sum_squares</code> exemplifies the most powerful property of user-defined functions. The function <code>sum_squares</code> is defined in terms of the function <code>square</code>, but relies only on the relationship that <code>square</code> defines between its input arguments and its output values.</p>
<p>We can write <code>sum_squares</code> without concerning ourselves with <em>how</em> to square a number. The details of how the square is computed can be suppressed, to be considered at a later time. Indeed, as far as <code>sum_squares</code> is concerned, <code>square</code> is not a particular function body, but rather an abstraction of a function, a so-called functional abstraction. At this level of abstraction, any function that computes the square is equally good.</p>
<p>Thus, considering only the values they return, the following two functions for squaring a number should be indistinguishable. Each takes a numerical argument and produces the square of that number as the value.</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm">&gt;&gt;&gt; def square(<span class="hljs-keyword">x</span>):<br>        return <span class="hljs-keyword">mul</span>(<span class="hljs-keyword">x</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">x</span>)<br>&gt;&gt;&gt; def square(<span class="hljs-keyword">x</span>):<br>        return <span class="hljs-keyword">mul</span>(<span class="hljs-keyword">x</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">x</span><span class="hljs-number">-1</span>) + <span class="hljs-keyword">x</span><br></code></pre></td></tr></table></figure>

<p>In other words, a function definition should be able to suppress details. The users of the function may not have written the function themselves, but may have obtained it from another programmer as a “black box”. A programmer should not need to know how the function is implemented in order to use it. The Python Library has this property. Many developers use the functions defined there, but few ever inspect their implementation.</p>
<p><strong>Aspects of a functional abstraction.</strong> To master the use of a functional abstraction, it is often useful to consider its three core attributes. The <em>domain</em> of a function is the set of arguments it can take. The <em>range</em> of a function is the set of values it can return. The <em>intent</em> of a function is the relationship it computes between inputs and output (as well as any side effects it might generate). Understanding functional abstractions via their domain, range, and intent is critical to using them correctly in a complex program.</p>
<p>For example, any <code>square</code> function that we use to implement <code>sum_squares</code> should have these attributes:</p>
<ul>
<li>The <em>domain</em> is any single real number.</li>
<li>The <em>range</em> is any non-negative real number.</li>
<li>The <em>intent</em> is that the output is the square of the input.</li>
</ul>
<p>These attributes do not specify how the intent is carried out; that detail is abstracted away.</p>
<h3 id="1-3-7-Operators"><a href="#1-3-7-Operators" class="headerlink" title="1.3.7  Operators"></a>1.3.7  Operators</h3><p>Mathematical operators (such as <code>+</code> and <code>-</code>) provided our first example of a method of combination, but we have yet to define an evaluation procedure for expressions that contain these operators.</p>
<p>Python expressions with infix operators each have their own evaluation procedures, but you can often think of them as short-hand for call expressions. When you see</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">2</span> + <span class="hljs-number">3</span></span><br>5<br></code></pre></td></tr></table></figure>

<p>simply consider it to be short-hand for</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span><br>5<br></code></pre></td></tr></table></figure>

<p>Infix notation can be nested, just like call expressions. Python applies the normal mathematical rules of operator precedence, which dictate how to interpret a compound expression with multiple operators.</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tap">&gt;&gt;&gt;<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>*<span class="hljs-number"> 4 </span>+ 5<br>19<br></code></pre></td></tr></table></figure>

<p>evaluates to the same result as</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&gt;&gt;&gt; <span class="hljs-built_in">add</span>(<span class="hljs-built_in">add</span>(2, mul(3, 4)), 5)<br>19<br></code></pre></td></tr></table></figure>

<p>The nesting in the call expression is more explicit than the operator version, but also harder to read. Python also allows subexpression grouping with parentheses, to override the normal precedence rules or make the nested structure of an expression more explicit.</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">&gt;&gt;&gt; <span class="hljs-comment">(2 + 3)</span> * <span class="hljs-comment">(4 + 5)</span><br><span class="hljs-number">45</span><br></code></pre></td></tr></table></figure>

<p>evaluates to the same result as</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&gt;&gt;&gt; mul(<span class="hljs-built_in">add</span>(2, 3), <span class="hljs-built_in">add</span>(4, 5))<br>45<br></code></pre></td></tr></table></figure>

<p>When it comes to division, Python provides two infix operators: <code>/</code> and <code>//</code>. The former is normal division, so that it results in a <em>floating point</em>, or decimal value, even if the divisor evenly divides the dividend:</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">5</span> / <span class="hljs-number">4</span></span><br>1.25<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">8</span> / <span class="hljs-number">4</span></span><br>2.0<br></code></pre></td></tr></table></figure>

<p>The <code>//</code> operator, on the other hand, rounds the result down to an integer:</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">5</span> // <span class="hljs-number">4</span></span><br>1<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">-<span class="hljs-number">5</span> // <span class="hljs-number">4</span></span><br>-2<br></code></pre></td></tr></table></figure>

<p>These two operators are shorthand for the <code>truediv</code> and <code>floordiv</code> functions.</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> truediv, floordiv</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">truediv(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>)</span><br>1.25<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">floordiv(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>)</span><br>1<br></code></pre></td></tr></table></figure>

<p>You should feel free to use infix operators and parentheses in your programs. Idiomatic Python prefers operators over call expressions for simple mathematical operations.</p>
<h2 id="1-4-Designing-Functions"><a href="#1-4-Designing-Functions" class="headerlink" title="1.4  Designing Functions"></a>1.4  Designing Functions</h2><p>Functions are an essential ingredient of all programs, large and small, and serve as our primary medium to express computational processes in a programming language. So far, we have discussed the formal properties of functions and how they are applied. We now turn to the topic of what makes a good function. Fundamentally, the qualities of good functions all reinforce the idea that functions are abstractions.</p>
<ul>
<li>Each function should have exactly one job. That job should be identifiable with a short name and characterizable in a single line of text. Functions that perform multiple jobs in sequence should be divided into multiple functions.</li>
<li><em>Don’t repeat yourself</em> is a central tenet of software engineering. The so-called DRY principle states that multiple fragments of code should not describe redundant logic. Instead, that logic should be implemented once, given a name, and applied multiple times. If you find yourself copying and pasting a block of code, you have probably found an opportunity for functional abstraction.</li>
<li>Functions should be defined generally. Squaring is not in the Python Library precisely because it is a special case of the <code>pow</code> function, which raises numbers to arbitrary powers.</li>
</ul>
<p>These guidelines improve the readability of code, reduce the number of errors, and often minimize the total amount of code written. Decomposing a complex task into concise functions is a skill that takes experience to master. Fortunately, Python provides several features to support your efforts.</p>
<h3 id="1-4-1-Documentation"><a href="#1-4-1-Documentation" class="headerlink" title="1.4.1  Documentation"></a>1.4.1  Documentation</h3><p>A function definition will often include documentation describing the function, called a <em>docstring</em>, which must be indented along with the function body. Docstrings are conventionally triple quoted. The first line describes the job of the function in one line. The following lines can describe arguments and clarify the behavior of the function:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">pressure</span>(<span class="hljs-params">v, t, n</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Compute the pressure in pascals of an ideal gas.</span><br><span class="hljs-string"></span><br><span class="hljs-string">        Applies the ideal gas law: http://en.wikipedia.org/wiki/Ideal_gas_law</span><br><span class="hljs-string"></span><br><span class="hljs-string">        v -- volume of gas, in cubic meters</span><br><span class="hljs-string">        t -- absolute temperature in degrees kelvin</span><br><span class="hljs-string">        n -- particles of gas</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        k = <span class="hljs-number">1.38e-23</span>  <span class="hljs-comment"># Boltzmann&#x27;s constant</span><br>        <span class="hljs-keyword">return</span> n * k * t / v<br></code></pre></td></tr></table></figure>

<p>When you call <code>help</code> with the name of a function as an argument, you see its docstring (type <code>q</code> to quit Python help).</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">help</span>(pressure)</span><br></code></pre></td></tr></table></figure>

<p>When writing Python programs, include docstrings for all but the simplest functions. Remember, code is written only once, but often read many times. The Python docs include <a target="_blank" rel="noopener" href="http://www.python.org/dev/peps/pep-0257/">docstring guidelines</a> that maintain consistency across different Python projects.</p>
<p><strong>Comments</strong>. Comments in Python can be attached to the end of a line following the <code>#</code> symbol. For example, the comment <code>Boltzmann&#39;s constant</code> above describes <code>k</code>. These comments don’t ever appear in Python’s <code>help</code>, and they are ignored by the interpreter. They exist for humans alone.</p>
<h3 id="1-4-2-Default-Argument-Values"><a href="#1-4-2-Default-Argument-Values" class="headerlink" title="1.4.2  Default Argument Values"></a>1.4.2  Default Argument Values</h3><p>A consequence of defining general functions is the introduction of additional arguments. Functions with many arguments can be awkward to call and difficult to read.</p>
<p>In Python, we can provide default values for the arguments of a function. When calling that function, arguments with default values are optional. If they are not provided, then the default value is bound to the formal parameter name instead. For instance, if an application commonly computes pressure for one mole of particles, this value can be provided as a default:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">pressure</span>(<span class="hljs-params">v, t, n=<span class="hljs-number">6.022e23</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Compute the pressure in pascals of an ideal gas.</span><br><span class="hljs-string"></span><br><span class="hljs-string">        v -- volume of gas, in cubic meters</span><br><span class="hljs-string">        t -- absolute temperature in degrees kelvin</span><br><span class="hljs-string">        n -- particles of gas (default: one mole)</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        k = <span class="hljs-number">1.38e-23</span>  <span class="hljs-comment"># Boltzmann&#x27;s constant</span><br>        <span class="hljs-keyword">return</span> n * k * t / v<br></code></pre></td></tr></table></figure>

<p>The <code>=</code> symbol means two different things in this example, depending on the context in which it is used. In the <code>def</code> statement header, <code>=</code> does not perform assignment, but instead indicates a default value to use when the <code>pressure</code> function is called. By contrast, the assignment statement to <code>k</code> in the body of the function binds the name <code>k</code> to an approximation of Boltzmann’s constant.</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">pressure(<span class="hljs-number">1</span>, <span class="hljs-number">273.15</span>)</span><br>2269.974834<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">pressure(<span class="hljs-number">1</span>, <span class="hljs-number">273.15</span>, <span class="hljs-number">3</span> * <span class="hljs-number">6.022e23</span>)</span><br>6809.924502<br></code></pre></td></tr></table></figure>

<p>The <code>pressure</code> function is defined to take three arguments, but only two are provided in the first call expression above. In this case, the value for <code>n</code> is taken from the <code>def</code> statement default. If a third argument is provided, the default is ignored.</p>
<p>As a guideline, most data values used in a function’s body should be expressed as default values to named arguments, so that they are easy to inspect and can be changed by the function caller. Some values that never change, such as the fundamental constant <code>k</code>, can be bound in the function body or in the global frame.</p>
<h2 id="1-5-Control"><a href="#1-5-Control" class="headerlink" title="1.5  Control"></a>1.5  Control</h2><p>The expressive power of the functions that we can define at this point is very limited, because we have not introduced a way to make comparisons and to perform different operations depending on the result of a comparison. <em>Control statements</em> will give us this ability. They are statements that control the flow of a program’s execution based on the results of logical comparisons.</p>
<p>Statements differ fundamentally from the expressions that we have studied so far. They have no value. Instead of computing something, executing a control statement determines what the interpreter should do next.</p>
<h3 id="1-5-1-Statements"><a href="#1-5-1-Statements" class="headerlink" title="1.5.1  Statements"></a>1.5.1  Statements</h3><p>So far, we have primarily considered how to evaluate expressions. However, we have seen three kinds of statements already: assignment, <code>def</code>, and <code>return</code> statements. These lines of Python code are not themselves expressions, although they all contain expressions as components.</p>
<p>Rather than being evaluated, statements are <em>executed</em>. Each statement describes some change to the interpreter state, and executing a statement applies that change. As we have seen for <code>return</code> and assignment statements, executing statements can involve evaluating subexpressions contained within them.</p>
<p>Expressions can also be executed as statements, in which case they are evaluated, but their value is discarded. Executing a pure function has no effect, but executing a non-pure function can cause effects as a consequence of function application.</p>
<p>Consider, for instance,</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">&gt;&gt;&gt; def square(<span class="hljs-keyword">x</span>):<br>        <span class="hljs-keyword">mul</span>(<span class="hljs-keyword">x</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">x</span>) # Watch out! This <span class="hljs-keyword">call</span> doesn&#x27;t return a value.<br></code></pre></td></tr></table></figure>

<p>This example is valid Python, but probably not what was intended. The body of the function consists of an expression. An expression by itself is a valid statement, but the effect of the statement is that the <code>mul</code> function is called, and the result is discarded. If you want to do something with the result of an expression, you need to say so: you might store it with an assignment statement or return it with a return statement:</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">&gt;&gt;&gt; def square(<span class="hljs-keyword">x</span>):<br>        return <span class="hljs-keyword">mul</span>(<span class="hljs-keyword">x</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">x</span>)<br></code></pre></td></tr></table></figure>

<p>Sometimes it does make sense to have a function whose body is an expression, when a non-pure function like <code>print</code> is called.</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl">&gt;&gt;&gt; <span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">print_square</span>(<span class="hljs-variable">x</span>):</span><br><span class="hljs-function">        <span class="hljs-title">print</span>(<span class="hljs-title">square</span>(<span class="hljs-variable">x</span>))</span><br></code></pre></td></tr></table></figure>

<p>At its highest level, the Python interpreter’s job is to execute programs, composed of statements. However, much of the interesting work of computation comes from evaluating expressions. Statements govern the relationship among different expressions in a program and what happens to their results.</p>
<h3 id="1-5-2-Compound-Statements"><a href="#1-5-2-Compound-Statements" class="headerlink" title="1.5.2  Compound Statements"></a>1.5.2  Compound Statements</h3><p>In general, Python code is a sequence of statements. A simple statement is a single line that doesn’t end in a colon. A compound statement is so called because it is composed of other statements (simple and compound). Compound statements typically span multiple lines and start with a one-line header ending in a colon, which identifies the type of statement. Together, a header and an indented suite of statements is called a clause. A compound statement consists of one or more clauses:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>:<br>    <span class="hljs-tag">&lt;<span class="hljs-name">statement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">statement</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;<span class="hljs-name">separating</span> <span class="hljs-attr">header</span>&gt;</span>:<br>    <span class="hljs-tag">&lt;<span class="hljs-name">statement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">statement</span>&gt;</span><br>    ...<br>...<br></code></pre></td></tr></table></figure>

<p>We can understand the statements we have already introduced in these terms.</p>
<ul>
<li>Expressions, return statements, and assignment statements are simple statements.</li>
<li>A <code>def</code> statement is a compound statement. The suite that follows the <code>def</code> header defines the function body.</li>
</ul>
<p>Specialized evaluation rules for each kind of header dictate when and if the statements in its suite are executed. We say that the header controls its suite. For example, in the case of <code>def</code> statements, we saw that the return expression is not evaluated immediately, but instead stored for later use when the defined function is eventually called.</p>
<p>We can also understand multi-line programs now.</p>
<ul>
<li>To execute a sequence of statements, execute the first statement. If that statement does not redirect control, then proceed to execute the rest of the sequence of statements, if any remain.</li>
</ul>
<p>This definition exposes the essential structure of a recursively defined <em>sequence</em>: a sequence can be decomposed into its first element and the rest of its elements. The “rest” of a sequence of statements is itself a sequence of statements! Thus, we can recursively apply this execution rule. This view of sequences as recursive data structures will appear again in later chapters.</p>
<p>The important consequence of this rule is that statements are executed in order, but later statements may never be reached, because of redirected control.</p>
<p><strong>Practical Guidance.</strong> When indenting a suite, all lines must be indented the same amount and in the same way (use spaces, not tabs). Any variation in indentation will cause an error.</p>
<h3 id="1-5-3-Defining-Functions-II-Local-Assignment"><a href="#1-5-3-Defining-Functions-II-Local-Assignment" class="headerlink" title="1.5.3  Defining Functions II: Local Assignment"></a>1.5.3  Defining Functions II: Local Assignment</h3><p>Originally, we stated that the body of a user-defined function consisted only of a <code>return</code> statement with a single return expression. In fact, functions can define a sequence of operations that extends beyond a single expression.</p>
<p>Whenever a user-defined function is applied, the sequence of clauses in the suite of its definition is executed in a local environment — an environment starting with a local frame created by calling that function. A <code>return</code> statement redirects control: the process of function application terminates whenever the first <code>return</code> statement is executed, and the value of the <code>return</code> expression is the returned value of the function being applied.</p>
<p>Assignment statements can appear within a function body. For instance, this function returns the absolute difference between two quantities as a percentage of the first, using a two-step calculation:</p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191817447.png" srcset="/img/loading.gif" lazyload></p>
<p>The effect of an assignment statement is to bind a name to a value in the <em>first</em> frame of the current environment. As a consequence, assignment statements within a function body cannot affect the global frame. The fact that functions can only manipulate their local environment is critical to creating <em>modular</em> programs, in which pure functions interact only via the values they take and return.</p>
<p>Of course, the <code>percent_difference</code> function could be written as a single expression, as shown below, but the return expression is more complex.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">percent_difference</span>(<span class="hljs-params">x, y</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">100</span> * <span class="hljs-built_in">abs</span>(x-y) / x<br><span class="hljs-meta">&gt;&gt;&gt; </span>percent_difference(<span class="hljs-number">40</span>, <span class="hljs-number">50</span>)<br><span class="hljs-number">25.0</span><br></code></pre></td></tr></table></figure>

<p>So far, local assignment hasn’t increased the expressive power of our function definitions. It will do so, when combined with other control statements. In addition, local assignment also plays a critical role in clarifying the meaning of complex expressions by assigning names to intermediate quantities.</p>
<h3 id="1-5-4-Conditional-Statements"><a href="#1-5-4-Conditional-Statements" class="headerlink" title="1.5.4  Conditional Statements"></a>1.5.4  Conditional Statements</h3><p>Python has a built-in function for computing absolute values.</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">abs</span>(-<span class="hljs-number">2</span>)</span><br>2<br></code></pre></td></tr></table></figure>

<p>We would like to be able to implement such a function ourselves, but we have no obvious way to define a function that has a comparison and a choice. We would like to express that if <code>x</code> is positive, <code>abs(x)</code> returns <code>x</code>. Furthermore, if <code>x</code> is 0, <code>abs(x)</code> returns 0. Otherwise, <code>abs(x)</code> returns <code>-x</code>. In Python, we can express this choice with a conditional statement.</p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191818095.png" srcset="/img/loading.gif" lazyload></p>
<p>This implementation of <code>absolute_value</code> raises several important issues:</p>
<p><strong>Conditional statements</strong>. A conditional statement in Python consists of a series of headers and suites: a required <code>if</code> clause, an optional sequence of <code>elif</code> clauses, and finally an optional <code>else</code> clause:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">if</span> <span class="hljs-symbol">&lt;expression&gt;</span>:<br>    <span class="hljs-symbol">&lt;suite&gt;</span><br>elif <span class="hljs-symbol">&lt;expression&gt;</span>:<br>    <span class="hljs-symbol">&lt;suite&gt;</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-symbol">&lt;suite&gt;</span><br></code></pre></td></tr></table></figure>

<p>When executing a conditional statement, each clause is considered in order. The computational process of executing a conditional clause follows.</p>
<ol>
<li>Evaluate the header’s expression.</li>
<li>If it is a true value, execute the suite. Then, skip over all subsequent clauses in the conditional statement.</li>
</ol>
<p>If the <code>else</code> clause is reached (which only happens if all <code>if</code> and <code>elif</code> expressions evaluate to false values), its suite is executed.</p>
<p><strong>Boolean contexts</strong>. Above, the execution procedures mention “a false value” and “a true value.” The expressions inside the header statements of conditional blocks are said to be in <em>boolean contexts</em>: their truth values matter to control flow, but otherwise their values are not assigned or returned. Python includes several false values, including 0, <code>None</code>, and the <em>boolean</em> value <code>False</code>. All other numbers are true values. In Chapter 2, we will see that every built-in kind of data in Python has both true and false values.</p>
<p><strong>Boolean values</strong>. Python has two boolean values, called <code>True</code> and <code>False</code>. Boolean values represent truth values in logical expressions. The built-in comparison operations, <code>&gt;, &lt;, &gt;=, &lt;=, ==, !=</code>, return these values.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">4</span> &lt; <span class="hljs-number">2</span><br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">5</span> &gt;= <span class="hljs-number">5</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>

<p>This second example reads “5 is greater than or equal to 5”, and corresponds to the function <code>ge</code> in the <code>operator</code> module.</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&gt;&gt;&gt; <span class="hljs-number">0</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> -<span class="hljs-number">0</span><br>True<br></code></pre></td></tr></table></figure>

<p>This final example reads “0 equals -0”, and corresponds to <code>eq</code> in the <code>operator</code> module. Notice that Python distinguishes assignment (<code>=</code>) from equality comparison (<code>==</code>), a convention shared across many programming languages.</p>
<p><strong>Boolean operators</strong>. Three basic logical operators are also built into Python:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> <span class="hljs-literal">False</span><br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span> <span class="hljs-keyword">or</span> <span class="hljs-literal">False</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">not</span> <span class="hljs-literal">False</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>

<p>Logical expressions have corresponding evaluation procedures. These procedures exploit the fact that the truth value of a logical expression can sometimes be determined without evaluating all of its subexpressions, a feature called <em>short-circuiting</em>.</p>
<p>To evaluate the expression <code>&lt;left&gt; and &lt;right&gt;</code>:</p>
<ol>
<li>Evaluate the subexpression <code>&lt;left&gt;</code>.</li>
<li>If the result is a false value <code>v</code>, then the expression evaluates to <code>v</code>.</li>
<li>Otherwise, the expression evaluates to the value of the subexpression <code>&lt;right&gt;</code>.</li>
</ol>
<p>To evaluate the expression <code>&lt;left&gt; or &lt;right&gt;</code>:</p>
<ol>
<li>Evaluate the subexpression <code>&lt;left&gt;</code>.</li>
<li>If the result is a true value <code>v</code>, then the expression evaluates to <code>v</code>.</li>
<li>Otherwise, the expression evaluates to the value of the subexpression <code>&lt;right&gt;</code>.</li>
</ol>
<p>To evaluate the expression <code>not &lt;exp&gt;</code>:</p>
<ol>
<li>Evaluate <code>&lt;exp&gt;</code>; The value is <code>True</code> if the result is a false value, and <code>False</code> otherwise.</li>
</ol>
<p>These values, rules, and operators provide us with a way to combine the results of comparisons. Functions that perform comparisons and return boolean values typically begin with <code>is</code>, not followed by an underscore (e.g., <code>isfinite</code>, <code>isdigit</code>, <code>isinstance</code>, etc.).</p>
<h3 id="1-5-5-Iteration"><a href="#1-5-5-Iteration" class="headerlink" title="1.5.5  Iteration"></a>1.5.5  Iteration</h3><p>In addition to selecting which statements to execute, control statements are used to express repetition. If each line of code we wrote were only executed once, programming would be a very unproductive exercise. Only through repeated execution of statements do we unlock the full potential of computers. We have already seen one form of repetition: a function can be applied many times, although it is only defined once. Iterative control structures are another mechanism for executing the same statements many times.</p>
<p>Consider the sequence of Fibonacci numbers, in which each number is the sum of the preceding two:</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">13</span>, <span class="hljs-number">21</span>, ...<br></code></pre></td></tr></table></figure>

<p>Each value is constructed by repeatedly applying the sum-previous-two rule. The first and second are fixed to 0 and 1. For instance, the eighth Fibonacci number is 13.</p>
<p>We can use a <code>while</code> statement to enumerate <code>n</code> Fibonacci numbers. We need to track how many values we’ve created (<code>k</code>), along with the kth value (<code>curr</code>) and its predecessor (<code>pred</code>). Step through this function and observe how the Fibonacci numbers evolve one by one, bound to <code>curr</code>.</p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191818999.png" srcset="/img/loading.gif" lazyload></p>
<p>Remember that commas seperate multiple names and values in an assignment statement. The line:</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">pred</span>, curr = curr, <span class="hljs-built_in">pred</span> + curr<br></code></pre></td></tr></table></figure>

<p>has the effect of rebinding the name <code>pred</code> to the value of <code>curr</code>, and simultanously rebinding <code>curr</code> to the value of <code>pred + curr</code>. All of the expressions to the right of <code>=</code> are evaluated before any rebinding takes place.</p>
<p>This order of events – evaluating everything on the right of <code>=</code> before updating any bindings on the left – is essential for correctness of this function.</p>
<p>A <code>while</code> clause contains a header expression followed by a suite:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">while</span> <span class="hljs-symbol">&lt;expression&gt;</span>:<br>    <span class="hljs-symbol">&lt;suite&gt;</span><br></code></pre></td></tr></table></figure>

<p>To execute a <code>while</code> clause:</p>
<ol>
<li>Evaluate the header’s expression.</li>
<li>If it is a true value, execute the suite, then return to step 1.</li>
</ol>
<p>In step 2, the entire suite of the <code>while</code> clause is executed before the header expression is evaluated again.</p>
<p>In order to prevent the suite of a <code>while</code> clause from being executed indefinitely, the suite should always change some binding in each pass.</p>
<p>A <code>while</code> statement that does not terminate is called an infinite loop. Press <code>&lt;Control&gt;-C</code> to force Python to stop looping.</p>
<h3 id="1-5-6-Testing"><a href="#1-5-6-Testing" class="headerlink" title="1.5.6  Testing"></a>1.5.6  Testing</h3><p><em>Testing</em> a function is the act of verifying that the function’s behavior matches expectations. Our language of functions is now sufficiently complex that we need to start testing our implementations.</p>
<p>A <em>test</em> is a mechanism for systematically performing this verification. Tests typically take the form of another function that contains one or more sample calls to the function being tested. The returned value is then verified against an expected result. Unlike most functions, which are meant to be general, tests involve selecting and validating calls with specific argument values. Tests also serve as documentation: they demonstrate how to call a function and what argument values are appropriate.</p>
<p><strong>Assertions.</strong> Programmers use <code>assert</code> statements to verify expectations, such as the output of a function being tested. An <code>assert</code> statement has an expression in a boolean context, followed by a quoted line of text (single or double quotes are both fine, but be consistent) that will be displayed if the expression evaluates to a false value.</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">assert</span> fib(<span class="hljs-number">8</span>) == <span class="hljs-number">13</span>, <span class="hljs-string">&#x27;The 8th Fibonacci number should be 13&#x27;</span></span><br></code></pre></td></tr></table></figure>

<p>When the expression being asserted evaluates to a true value, executing an assert statement has no effect. When it is a false value, <code>assert</code> causes an error that halts execution.</p>
<p>A test function for <code>fib</code> should test several arguments, including extreme values of <code>n</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;&gt;&gt; def <span class="hljs-title function_">fib_test</span><span class="hljs-params">()</span>:<br>        <span class="hljs-keyword">assert</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span> == <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;The 2nd Fibonacci number should be 1&#x27;</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span> == <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;The 3rd Fibonacci number should be 1&#x27;</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span> == <span class="hljs-number">7778742049</span>, <span class="hljs-string">&#x27;Error at the 50th Fibonacci number&#x27;</span><br></code></pre></td></tr></table></figure>

<p>When writing Python in files, rather than directly into the interpreter, tests are typically written in the same file or a neighboring file with the suffix <code>_test.py</code>.</p>
<p><strong>Doctests.</strong> Python provides a convenient method for placing simple tests directly in the docstring of a function. The first line of a docstring should contain a one-line description of the function, followed by a blank line. A detailed description of arguments and behavior may follow. In addition, the docstring may include a sample interactive session that calls the function:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum_naturals</span>(<span class="hljs-params">n</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Return the sum of the first n natural numbers.</span><br><span class="hljs-string"></span><br><span class="hljs-string">        &gt;&gt;&gt; sum_naturals(10)</span><br><span class="hljs-string">        55</span><br><span class="hljs-string">        &gt;&gt;&gt; sum_naturals(100)</span><br><span class="hljs-string">        5050</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        total, k = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> k &lt;= n:<br>            total, k = total + k, k + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> total<br></code></pre></td></tr></table></figure>

<p>Then, the interaction can be verified via the <a target="_blank" rel="noopener" href="http://docs.python.org/py3k/library/doctest.html">doctest module</a>. Below, the <code>globals</code> function returns a representation of the global environment, which the interpreter needs in order to evaluate expressions.</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">from</span> doctest <span class="hljs-keyword">import</span> testmod</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">testmod()</span><br>TestResults(failed=0, attempted=2)<br></code></pre></td></tr></table></figure>

<p>To verify the doctest interactions for only a single function, we use a <code>doctest</code> function called <code>run_docstring_examples</code>. This function is (unfortunately) a bit complicated to call. Its first argument is the function to test. The second should always be the result of the expression <code>globals()</code>, a built-in function that returns the global environment. The third argument is <code>True</code> to indicate that we would like “verbose” output: a catalog of all tests run.</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">from</span> doctest <span class="hljs-keyword">import</span> run_docstring_examples</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">run_docstring_examples(sum_naturals, <span class="hljs-built_in">globals</span>(), <span class="hljs-literal">True</span>)</span><br>Finding tests in NoName<br>Trying:<br>    sum_naturals(10)<br>Expecting:<br>    55<br>ok<br>Trying:<br>    sum_naturals(100)<br>Expecting:<br>    5050<br>ok<br></code></pre></td></tr></table></figure>

<p>When the return value of a function does not match the expected result, the <code>run_docstring_examples</code> function will report this problem as a test failure.</p>
<p>When writing Python in files, all doctests in a file can be run by starting Python with the doctest command line option:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python3</span> -<span class="hljs-keyword">m</span> doctest <span class="hljs-symbol">&lt;python_source_file&gt;</span><br></code></pre></td></tr></table></figure>

<p>The key to effective testing is to write (and run) tests immediately after implementing new functions. It is even good practice to write some tests before you implement, in order to have some example inputs and outputs in your mind. A test that applies a single function is called a <em>unit test</em>. Exhaustive unit testing is a hallmark of good program design.</p>
<h2 id="1-6-Higher-Order-Functions"><a href="#1-6-Higher-Order-Functions" class="headerlink" title="1.6  Higher-Order Functions"></a>1.6  Higher-Order Functions</h2><p>We have seen that functions are a method of abstraction that describe compound operations independent of the particular values of their arguments. That is, in <code>square</code>,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">square</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">return</span> x * x<br></code></pre></td></tr></table></figure>

<p>we are not talking about the square of a particular number, but rather about a method for obtaining the square of any number. Of course, we could get along without ever defining this function, by always writing expressions such as</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">3</span> * <span class="hljs-number">3</span></span><br>9<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">5</span> * <span class="hljs-number">5</span></span><br>25<br></code></pre></td></tr></table></figure>

<p>and never mentioning <code>square</code> explicitly. This practice would suffice for simple computations such as <code>square</code>, but would become arduous for more complex examples such as <code>abs</code> or <code>fib</code>. In general, lacking function definition would put us at the disadvantage of forcing us to work always at the level of the particular operations that happen to be primitives in the language (multiplication, in this case) rather than in terms of higher-level operations. Our programs would be able to compute squares, but our language would lack the ability to express the concept of squaring.</p>
<p>One of the things we should demand from a powerful programming language is the ability to build abstractions by assigning names to common patterns and then to work in terms of the names directly. Functions provide this ability. As we will see in the following examples, there are common programming patterns that recur in code, but are used with a number of different functions. These patterns can also be abstracted, by giving them names.</p>
<p>To express certain general patterns as named concepts, we will need to construct functions that can accept other functions as arguments or return functions as values. Functions that manipulate functions are called higher-order functions. This section shows how higher-order functions can serve as powerful abstraction mechanisms, vastly increasing the expressive power of our language.</p>
<h3 id="1-6-1-Functions-as-Arguments"><a href="#1-6-1-Functions-as-Arguments" class="headerlink" title="1.6.1  Functions as Arguments"></a>1.6.1  Functions as Arguments</h3><p>Consider the following three functions, which all compute summations. The first, <code>sum_naturals</code>, computes the sum of natural numbers up to <code>n</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum_naturals</span>(<span class="hljs-params">n</span>):<br>        total, k = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> k &lt;= n:<br>            total, k = total + k, k + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> total<br><span class="hljs-meta">&gt;&gt;&gt; </span>sum_naturals(<span class="hljs-number">100</span>)<br><span class="hljs-number">5050</span><br></code></pre></td></tr></table></figure>

<p>The second, <code>sum_cubes</code>, computes the sum of the cubes of natural numbers up to <code>n</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum_cubes</span>(<span class="hljs-params">n</span>):<br>        total, k = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> k &lt;= n:<br>            total, k = total + k*k*k, k + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> total<br><span class="hljs-meta">&gt;&gt;&gt; </span>sum_cubes(<span class="hljs-number">100</span>)<br><span class="hljs-number">25502500</span><br></code></pre></td></tr></table></figure>

<p>The third, <code>pi_sum</code>, computes the sum of terms in the series</p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191819153.png" srcset="/img/loading.gif" lazyload></p>
<p>which converges to pi very slowly.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">pi_sum</span>(<span class="hljs-params">n</span>):<br>        total, k = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> k &lt;= n:<br>            total, k = total + <span class="hljs-number">8</span> / ((<span class="hljs-number">4</span>*k-<span class="hljs-number">3</span>) * (<span class="hljs-number">4</span>*k-<span class="hljs-number">1</span>)), k + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> total<br><span class="hljs-meta">&gt;&gt;&gt; </span>pi_sum(<span class="hljs-number">100</span>)<br><span class="hljs-number">3.1365926848388144</span><br></code></pre></td></tr></table></figure>

<p>These three functions clearly share a common underlying pattern. They are for the most part identical, differing only in name and the function of <code>k</code> used to compute the term to be added. We could generate each of the functions by filling in slots in the same template:</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata">def &lt;name&gt;(<span class="hljs-keyword">n</span>):<br>    <span class="hljs-keyword">total</span>, k = 0, 1<br>    <span class="hljs-keyword">while</span> k &lt;= <span class="hljs-keyword">n</span>:<br>        <span class="hljs-keyword">total</span>, k = <span class="hljs-keyword">total</span> + &lt;term&gt;(k), k + 1<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">total</span><br></code></pre></td></tr></table></figure>

<p>The presence of such a common pattern is strong evidence that there is a useful abstraction waiting to be brought to the surface. Each of these functions is a summation of terms. As program designers, we would like our language to be powerful enough so that we can write a function that expresses the concept of summation itself rather than only functions that compute particular sums. We can do so readily in Python by taking the common template shown above and transforming the “slots” into formal parameters:</p>
<p>In the example below, <code>summation</code> takes as its two arguments the upper bound <code>n</code> together with the function <code>term</code> that computes the kth term. We can use <code>summation</code> just as we would any function, and it expresses summations succinctly. Take the time to step through this example, and notice how binding <code>cube</code> to the local names <code>term</code> ensures that the result <code>1*1*1 + 2*2*2 + 3*3*3 = 36</code> is computed correctly. In this example, frames which are no longer needed are removed to save space.</p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191819820.png" srcset="/img/loading.gif" lazyload></p>
<p>Using an <code>identity</code> function that returns its argument, we can also sum natural numbers using exactly the same <code>summation</code> function.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">summation</span>(<span class="hljs-params">n, term</span>):<br>        total, k = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> k &lt;= n:<br>            total, k = total + term(k), k + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> total<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">identity</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">return</span> x<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum_naturals</span>(<span class="hljs-params">n</span>):<br>        <span class="hljs-keyword">return</span> summation(n, identity)<br><span class="hljs-meta">&gt;&gt;&gt; </span>sum_naturals(<span class="hljs-number">10</span>)<br><span class="hljs-number">55</span><br></code></pre></td></tr></table></figure>

<p>The <code>summation</code> function can also be called directly, without definining another function for a specific sequence.</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">summation(<span class="hljs-number">10</span>, square)</span><br>385<br></code></pre></td></tr></table></figure>

<p>We can define <code>pi_sum</code> using our <code>summation</code> abstraction by defining a function <code>pi_term</code> to compute each term. We pass the argument <code>1e6</code>, a shorthand for <code>1 * 10^6 = 1000000</code>, to generate a close approximation to pi.</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">pi_term</span>(<span class="hljs-params">x</span>):</span><br>        return 8 / ((4*x-3) * (4*x-1))<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">pi_sum</span>(<span class="hljs-params">n</span>):</span><br>        return summation(n, pi_term)<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">pi_sum(<span class="hljs-number">1e6</span>)</span><br>3.141592153589902<br></code></pre></td></tr></table></figure>

<h3 id="1-6-2-Functions-as-General-Methods"><a href="#1-6-2-Functions-as-General-Methods" class="headerlink" title="1.6.2  Functions as General Methods"></a>1.6.2  Functions as General Methods</h3><p>We introduced user-defined functions as a mechanism for abstracting patterns of numerical operations so as to make them independent of the particular numbers involved. With higher-order functions, we begin to see a more powerful kind of abstraction: some functions express general methods of computation, independent of the particular functions they call.</p>
<p>Despite this conceptual extension of what a function means, our environment model of how to evaluate a call expression extends gracefully to the case of higher-order functions, without change. When a user-defined function is applied to some arguments, the formal parameters are bound to the values of those arguments (which may be functions) in a new local frame.</p>
<p>Consider the following example, which implements a general method for iterative improvement and uses it to compute the <a target="_blank" rel="noopener" href="http://www.geom.uiuc.edu/~demo5337/s97b/art.htm">golden ratio</a>. The golden ratio, often called “phi”, is a number near 1.6 that appears frequently in nature, art, and architecture.</p>
<p>An iterative improvement algorithm begins with a <code>guess</code> of a solution to an equation. It repeatedly applies an <code>update</code> function to improve that guess, and applies a <code>close</code> comparison to check whether the current <code>guess</code> is “close enough” to be considered correct.</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&gt;&gt;&gt; def improve(<span class="hljs-keyword">update</span>, <span class="hljs-keyword">close</span>, guess=<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">close</span>(guess):<br>            guess = <span class="hljs-keyword">update</span>(guess)<br>        <span class="hljs-keyword">return</span> guess<br></code></pre></td></tr></table></figure>

<p>This <code>improve</code> function is a general expression of repetitive refinement. It doesn’t specify what problem is being solved: those details are left to the <code>update</code> and <code>close</code> functions passed in as arguments.</p>
<p>Among the well-known properties of the golden ratio are that it can be computed by repeatedly summing the inverse of any positive number with 1, and that it is one less than its square. We can express these properties as functions to be used with <code>improve</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">golden_update</span>(<span class="hljs-params">guess</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>/guess + <span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">square_close_to_successor</span>(<span class="hljs-params">guess</span>):<br>        <span class="hljs-keyword">return</span> approx_eq(guess * guess, guess + <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>

<p>Above, we introduce a call to <code>approx_eq</code> that is meant to return <code>True</code> if its arguments are approximately equal to each other. To implement, <code>approx_eq</code>, we can compare the absolute value of the difference between two numbers to a small tolerance value.</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">&gt;&gt;&gt; def approx_e<span class="hljs-string">q(x, y, tolerance=1e-15)</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">abs</span>(<span class="hljs-keyword">x</span> - <span class="hljs-keyword">y</span>) &lt; tolerance<br></code></pre></td></tr></table></figure>

<p>Calling <code>improve</code> with the arguments <code>golden_update</code> and <code>square_close_to_successor</code> will compute a finite approximation to the golden ratio.</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">improve(golden_update, square_close_to_successor)</span><br>1.6180339887498951<br></code></pre></td></tr></table></figure>

<p>By tracing through the steps of evaluation, we can see how this result is computed. First, a local frame for <code>improve</code> is constructed with bindings for <code>update</code>, <code>close</code>, and <code>guess</code>. In the body of <code>improve</code>, the name <code>close</code> is bound to <code>square_close_to_successor</code>, which is called on the initial value of <code>guess</code>. Trace through the rest of the steps to see the computational process that evolves to compute the golden ratio.</p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191820732.png" srcset="/img/loading.gif" lazyload></p>
<p>This example illustrates two related big ideas in computer science. First, naming and functions allow us to abstract away a vast amount of complexity. While each function definition has been trivial, the computational process set in motion by our evaluation procedure is quite intricate. Second, it is only by virtue of the fact that we have an extremely general evaluation procedure for the Python language that small components can be composed into complex processes. Understanding the procedure of interpreting programs allows us to validate and inspect the process we have created.</p>
<p>As always, our new general method <code>improve</code> needs a test to check its correctness. The golden ratio can provide such a test, because it also has an exact closed-form solution, which we can compare to this iterative result.</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">phi = <span class="hljs-number">1</span>/<span class="hljs-number">2</span> + sqrt(<span class="hljs-number">5</span>)/<span class="hljs-number">2</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">improve_test</span>():</span><br>        approx_phi = improve(golden_update, square_close_to_successor)<br>        assert approx_eq(phi, approx_phi), &#x27;phi differs from its approximation&#x27;<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">improve_test()</span><br></code></pre></td></tr></table></figure>

<p>For this test, no news is good news: <code>improve_test</code> returns <code>None</code> after its <code>assert</code> statement is executed successfully.</p>
<h3 id="1-6-3-Defining-Functions-III-Nested-Definitions"><a href="#1-6-3-Defining-Functions-III-Nested-Definitions" class="headerlink" title="1.6.3  Defining Functions III: Nested Definitions"></a>1.6.3  Defining Functions III: Nested Definitions</h3><p>The above examples demonstrate how the ability to pass functions as arguments significantly enhances the expressive power of our programming language. Each general concept or equation maps onto its own short function. One negative consequence of this approach is that the global frame becomes cluttered with names of small functions, which must all be unique. Another problem is that we are constrained by particular function signatures: the <code>update</code> argument to <code>improve</code> must take exactly one argument. Nested function definitions address both of these problems, but require us to enrich our environment model.</p>
<p>Let’s consider a new problem: computing the square root of a number. In programming languages, “square root” is often abbreviated as <code>sqrt</code>. Repeated application of the following update converges to the square root of <code>a</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">average</span>(<span class="hljs-params">x, y</span>):<br>        <span class="hljs-keyword">return</span> (x + y)/<span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">sqrt_update</span>(<span class="hljs-params">x, a</span>):<br>        <span class="hljs-keyword">return</span> average(x, a/x)<br></code></pre></td></tr></table></figure>

<p>This two-argument update function is incompatible with <code>improve</code> (it takes two arguments, not one), and it provides only a single update, while we really care about taking square roots by repeated updates. The solution to both of these issues is to place function definitions inside the body of other definitions.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">sqrt</span>(<span class="hljs-params">a</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">sqrt_update</span>(<span class="hljs-params">x</span>):<br>            <span class="hljs-keyword">return</span> average(x, a/x)<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">sqrt_close</span>(<span class="hljs-params">x</span>):<br>            <span class="hljs-keyword">return</span> approx_eq(x * x, a)<br>        <span class="hljs-keyword">return</span> improve(sqrt_update, sqrt_close)<br></code></pre></td></tr></table></figure>

<p>Like local assignment, local <code>def</code> statements only affect the current local frame. These functions are only in scope while <code>sqrt</code> is being evaluated. Consistent with our evaluation procedure, these local <code>def</code> statements don’t even get evaluated until <code>sqrt</code> is called.</p>
<p><strong>Lexical scope.</strong> Locally defined functions also have access to the name bindings in the scope in which they are defined. In this example, <code>sqrt_update</code> refers to the name <code>a</code>, which is a formal parameter of its enclosing function <code>sqrt</code>. This discipline of sharing names among nested definitions is called <em>lexical scoping</em>. Critically, the inner functions have access to the names in the environment where they are defined (not where they are called).</p>
<p>We require two extensions to our environment model to enable lexical scoping.</p>
<ol>
<li>Each user-defined function has a parent environment: the environment in which it was defined.</li>
<li>When a user-defined function is called, its local frame extends its parent environment.</li>
</ol>
<p>Previous to <code>sqrt</code>, all functions were defined in the global environment, and so they all had the same parent: the global environment. By contrast, when Python evaluates the first two clauses of <code>sqrt</code>, it create functions that are associated with a local environment. In the call</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl">&gt;&gt;&gt; <span class="hljs-function"><span class="hljs-title">sqrt</span>(<span class="hljs-number">256</span>)</span><br><span class="hljs-number">16.0</span><br></code></pre></td></tr></table></figure>

<p>the environment first adds a local frame for <code>sqrt</code> and evaluates the <code>def</code> statements for <code>sqrt_update</code> and <code>sqrt_close</code>.</p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191820683.png" srcset="/img/loading.gif" lazyload></p>
<p>Function values each have a new annotation that we will include in environment diagrams from now on, a <em>parent</em>. The parent of a function value is the first frame of the environment in which that function was defined. Functions without parent annotations were defined in the global environment. When a user-defined function is called, the frame created has the same parent as that function.</p>
<p>Subsequently, the name <code>sqrt_update</code> resolves to this newly defined function, which is passed as an argument to <code>improve</code>. Within the body of <code>improve</code>, we must apply our <code>update</code> function (bound to <code>sqrt_update</code>) to the initial guess <code>x</code> of 1. This final application creates an environment for <code>sqrt_update</code> that begins with a local frame containing only <code>x</code>, but with the parent frame <code>sqrt</code> still containing a binding for <code>a</code>.</p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191821208.png" srcset="/img/loading.gif" lazyload></p>
<p>The most critical part of this evaluation procedure is the transfer of the parent for <code>sqrt_update</code> to the frame created by calling <code>sqrt_update</code>. This frame is also annotated with <code>[parent=f1]</code>.</p>
<p><strong>Extended Environments</strong>. An environment can consist of an arbitrarily long chain of frames, which always concludes with the global frame. Previous to this <code>sqrt</code> example, environments had at most two frames: a local frame and the global frame. By calling functions that were defined within other functions, via nested <code>def</code> statements, we can create longer chains. The environment for this call to <code>sqrt_update</code> consists of three frames: the local <code>sqrt_update</code> frame, the <code>sqrt</code> frame in which <code>sqrt_update</code> was defined (labeled <code>f1</code>), and the global frame.</p>
<p>The return expression in the body of <code>sqrt_update</code> can resolve a value for <code>a</code> by following this chain of frames. Looking up a name finds the first value bound to that name in the current environment. Python checks first in the <code>sqrt_update</code> frame – no <code>a</code> exists. Python checks next in the parent frame, <code>f1</code>, and finds a binding for <code>a</code> to 256.</p>
<p>Hence, we realize two key advantages of lexical scoping in Python.</p>
<ul>
<li>The names of a local function do not interfere with names external to the function in which it is defined, because the local function name will be bound in the current local environment in which it was defined, rather than the global environment.</li>
<li>A local function can access the environment of the enclosing function, because the body of the local function is evaluated in an environment that extends the evaluation environment in which it was defined.</li>
</ul>
<p>The <code>sqrt_update</code> function carries with it some data: the value for <code>a</code> referenced in the environment in which it was defined. Because they “enclose” information in this way, locally defined functions are often called <em>closures</em>.</p>
<h3 id="1-6-4-Functions-as-Returned-Values"><a href="#1-6-4-Functions-as-Returned-Values" class="headerlink" title="1.6.4  Functions as Returned Values"></a>1.6.4  Functions as Returned Values</h3><p>We can achieve even more expressive power in our programs by creating functions whose returned values are themselves functions. An important feature of lexically scoped programming languages is that locally defined functions maintain their parent environment when they are returned. The following example illustrates the utility of this feature.</p>
<p>Once many simple functions are defined, function <em>composition</em> is a natural method of combination to include in our programming language. That is, given two functions <code>f(x)</code> and <code>g(x)</code>, we might want to define <code>h(x) = f(g(x))</code>. We can define function composition using our existing tools:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">compose1</span>(<span class="hljs-params">f, g</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">h</span>(<span class="hljs-params">x</span>):<br>            <span class="hljs-keyword">return</span> f(g(x))<br>        <span class="hljs-keyword">return</span> h<br></code></pre></td></tr></table></figure>

<p>The environment diagram for this example shows how the names <code>f</code> and <code>g</code> are resolved correctly, even in the presence of conflicting names.</p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191821735.png" srcset="/img/loading.gif" lazyload></p>
<p>The 1 in <code>compose1</code> is meant to signify that the composed functions all take a single argument. This naming convention is not enforced by the interpreter; the 1 is just part of the function name.</p>
<p>At this point, we begin to observe the benefits of our effort to define precisely the environment model of computation. No modification to our environment model is required to explain our ability to return functions in this way.</p>
<h3 id="1-6-5-Example-Newton’s-Method"><a href="#1-6-5-Example-Newton’s-Method" class="headerlink" title="1.6.5  Example: Newton’s Method"></a>1.6.5  Example: Newton’s Method</h3><p>This extended example shows how function return values and local definitions can work together to express general ideas concisely. We will implement an algorithm that is used broadly in machine learning, scientific computing, hardware design, and optimization.</p>
<p>Newton’s method is a classic iterative approach to finding the arguments of a mathematical function that yield a return value of 0. These values are called the <em>zeros</em> of the function. Finding a zero of a function is often equivalent to solving some other problem of interest, such as computing a square root.</p>
<p>A motivating comment before we proceed: it is easy to take for granted the fact that we know how to compute square roots. Not just Python, but your phone, web browser, or pocket calculator can do so for you. However, part of learning computer science is understanding how quantities like these can be computed, and the general approach presented here is applicable to solving a large class of equations beyond those built into Python.</p>
<p>Newton’s method is an iterative improvement algorithm: it improves a guess of the zero for any function that is <em>differentiable</em>, which means that it can be approximated by a straight line at any point. Newton’s method follows these linear approximations to find function zeros.</p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191843146.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191822519.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>A <code>newton_update</code> expresses the computational process of following this tangent line to 0, for a function <code>f</code> and its derivative <code>df</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">newton_update</span>(<span class="hljs-params">f, df</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">x</span>):<br>            <span class="hljs-keyword">return</span> x - f(x) / df(x)<br>        <span class="hljs-keyword">return</span> update<br></code></pre></td></tr></table></figure>

<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191843782.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">&gt;&gt;&gt; def find_zero(f, df):<br>        def near_zero(<span class="hljs-keyword">x</span>):<br>            <span class="hljs-keyword">return</span> approx_e<span class="hljs-string">q(f(x)</span>, <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> improve(newton_update(f, df), near_zero)<br></code></pre></td></tr></table></figure>

<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191842997.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191822805.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191842811.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">square_root_newton</span>(<span class="hljs-params">a</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>):<br>            <span class="hljs-keyword">return</span> x * x - a<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">df</span>(<span class="hljs-params">x</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * x<br>        <span class="hljs-keyword">return</span> find_zero(f, df)<br><span class="hljs-meta">&gt;&gt;&gt; </span>square_root_newton(<span class="hljs-number">64</span>)<br><span class="hljs-number">8.0</span><br></code></pre></td></tr></table></figure>

<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191841110.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">power</span>(<span class="hljs-params">x, n</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Return x * x * x * ... * x for x repeated n times.&quot;&quot;&quot;</span><br>        product, k = <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> k &lt; n:<br>            product, k = product * x, k + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> product<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">nth_root_of_a</span>(<span class="hljs-params">n, a</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>):<br>            <span class="hljs-keyword">return</span> power(x, n) - a<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">df</span>(<span class="hljs-params">x</span>):<br>            <span class="hljs-keyword">return</span> n * power(x, n-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> find_zero(f, df)<br><span class="hljs-meta">&gt;&gt;&gt; </span>nth_root_of_a(<span class="hljs-number">2</span>, <span class="hljs-number">64</span>)<br><span class="hljs-number">8.0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>nth_root_of_a(<span class="hljs-number">3</span>, <span class="hljs-number">64</span>)<br><span class="hljs-number">4.0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>nth_root_of_a(<span class="hljs-number">6</span>, <span class="hljs-number">64</span>)<br><span class="hljs-number">2.0</span><br></code></pre></td></tr></table></figure>

<p>The approximation error in all of these computations can be reduced by changing the <code>tolerance</code> in <code>approx_eq</code> to a smaller number.</p>
<p>As you experiment with Newton’s method, be aware that it will not always converge. The initial guess of <code>improve</code> must be sufficiently close to the zero, and various conditions about the function must be met. Despite this shortcoming, Newton’s method is a powerful general computational method for solving differentiable equations. Very fast algorithms for logarithms and large integer division employ variants of the technique in modern computers.</p>
<h3 id="1-6-6-Currying"><a href="#1-6-6-Currying" class="headerlink" title="1.6.6  Currying"></a>1.6.6  Currying</h3><p>We can use higher-order functions to convert a function that takes multiple arguments into a chain of functions that each take a single argument. More specifically, given a function <code>f(x, y)</code>, we can define a function <code>g</code> such that <code>g(x)(y)</code> is equivalent to <code>f(x, y)</code>. Here, <code>g</code> is a higher-order function that takes in a single argument <code>x</code> and returns another function that takes in a single argument <code>y</code>. This transformation is called <em>currying</em>.</p>
<p>As an example, we can define a curried version of the <code>pow</code> function:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">curried_pow</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">h</span>(<span class="hljs-params">y</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(x, y)<br>        <span class="hljs-keyword">return</span> h<br><span class="hljs-meta">&gt;&gt;&gt; </span>curried_pow(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)<br><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure>

<p>Some programming languages, such as Haskell, only allow functions that take a single argument, so the programmer must curry all multi-argument procedures. In more general languages such as Python, currying is useful when we require a function that takes in only a single argument. For example, the <em>map</em> pattern applies a single-argument function to a sequence of values. In later chapters, we will see more general examples of the map pattern, but for now, we can implement the pattern in a function:</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">&gt;&gt;&gt; def map_to_range(<span class="hljs-built_in">start</span>, <span class="hljs-keyword">end</span>, f):<br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">start</span> &lt; <span class="hljs-keyword">end</span>:<br>            print(f(<span class="hljs-built_in">start</span>))<br>            <span class="hljs-built_in">start</span> = <span class="hljs-built_in">start</span> + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>We can use <code>map_to_range</code> and <code>curried_pow</code> to compute the first ten powers of two, rather than specifically writing a function to do so:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lisp">&gt;&gt;&gt; map_to_range(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, curried_pow(<span class="hljs-number">2</span>))<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">4</span><br><span class="hljs-number">8</span><br><span class="hljs-number">16</span><br><span class="hljs-number">32</span><br><span class="hljs-number">64</span><br><span class="hljs-number">128</span><br><span class="hljs-number">256</span><br><span class="hljs-number">512</span><br></code></pre></td></tr></table></figure>

<p>We can similarly use the same two functions to compute powers of other numbers. Currying allows us to do so without writing a specific function for each number whose powers we wish to compute.</p>
<p>In the above examples, we manually performed the currying transformation on the <code>pow</code> function to obtain <code>curried_pow</code>. Instead, we can define functions to automate currying, as well as the inverse <em>uncurrying</em> transformation:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">curry2</span>(<span class="hljs-params">f</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Return a curried version of the given two-argument function.&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">g</span>(<span class="hljs-params">x</span>):<br>            <span class="hljs-keyword">def</span> <span class="hljs-title function_">h</span>(<span class="hljs-params">y</span>):<br>                <span class="hljs-keyword">return</span> f(x, y)<br>            <span class="hljs-keyword">return</span> h<br>        <span class="hljs-keyword">return</span> g<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">uncurry2</span>(<span class="hljs-params">g</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Return a two-argument version of the given curried function.&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x, y</span>):<br>            <span class="hljs-keyword">return</span> g(x)(y)<br>        <span class="hljs-keyword">return</span> f<br><span class="hljs-meta">&gt;&gt;&gt; </span>pow_curried = curry2(<span class="hljs-built_in">pow</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>pow_curried(<span class="hljs-number">2</span>)(<span class="hljs-number">5</span>)<br><span class="hljs-number">32</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>map_to_range(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, pow_curried(<span class="hljs-number">2</span>))<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">4</span><br><span class="hljs-number">8</span><br><span class="hljs-number">16</span><br><span class="hljs-number">32</span><br><span class="hljs-number">64</span><br><span class="hljs-number">128</span><br><span class="hljs-number">256</span><br><span class="hljs-number">512</span><br></code></pre></td></tr></table></figure>

<p>The <code>curry2</code> function takes in a two-argument function <code>f</code> and returns a single-argument function <code>g</code>. When <code>g</code> is applied to an argument <code>x</code>, it returns a single-argument function <code>h</code>. When <code>h</code> is applied to <code>y</code>, it calls <code>f(x, y)</code>. Thus, <code>curry2(f)(x)(y)</code> is equivalent to <code>f(x, y)</code>. The <code>uncurry2</code> function reverses the currying transformation, so that <code>uncurry2(curry2(f))</code> is equivalent to <code>f</code>.</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">&gt;&gt;&gt; u<span class="hljs-symbol">ncurry2</span><span class="hljs-comment">(pow_curried)</span><span class="hljs-comment">(2, 5)</span><br><span class="hljs-number">32</span><br></code></pre></td></tr></table></figure>

<h3 id="1-6-7-Lambda-Expressions"><a href="#1-6-7-Lambda-Expressions" class="headerlink" title="1.6.7  Lambda Expressions"></a>1.6.7  Lambda Expressions</h3><p>So far, each time we have wanted to define a new function, we needed to give it a name. But for other types of expressions, we don’t need to associate intermediate values with a name. That is, we can compute <code>a*b + c*d</code> without having to name the subexpressions <code>a*b</code> or <code>c*d</code>, or the full expression. In Python, we can create function values on the fly using <code>lambda</code> expressions, which evaluate to unnamed functions. A lambda expression evaluates to a function that has a single return expression as its body. Assignment and control statements are not allowed.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">compose1</span>(<span class="hljs-params">f, g</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">lambda</span> x: f(g(x))<br></code></pre></td></tr></table></figure>

<p>We can understand the structure of a <code>lambda</code> expression by constructing a corresponding English sentence:</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl">     <span class="hljs-variable">lambda</span>            <span class="hljs-variable">x</span>            :          <span class="hljs-function"><span class="hljs-title">f</span>(<span class="hljs-title">g</span>(<span class="hljs-variable">x</span>))</span><br><span class="hljs-string">&quot;A function that    takes x    and returns     f(g(x))&quot;</span><br></code></pre></td></tr></table></figure>

<p>The result of a lambda expression is called a lambda function. It has no intrinsic name (and so Python prints <code>&lt;lambda&gt;</code> for the name), but otherwise it behaves like any other function.</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">s = <span class="hljs-keyword">lambda</span> x: x * x</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">s</span><br>&lt;function &lt;lambda&gt; at 0xf3f490&gt;<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">s(<span class="hljs-number">12</span>)</span><br>144<br></code></pre></td></tr></table></figure>

<p>In an environment diagram, the result of a lambda expression is a function as well, named with the greek letter λ (lambda). Our compose example can be expressed quite compactly with lambda expressions.</p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191822583.png" srcset="/img/loading.gif" lazyload></p>
<p>Some programmers find that using unnamed functions from lambda expressions to be shorter and more direct. However, compound <code>lambda</code> expressions are notoriously illegible, despite their brevity. The following definition is correct, but many programmers have trouble understanding it quickly.</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">compose1 = <span class="hljs-keyword">lambda</span> f,g: <span class="hljs-keyword">lambda</span> x: f(g(x))</span><br></code></pre></td></tr></table></figure>

<p>In general, Python style prefers explicit <code>def</code> statements to lambda expressions, but allows them in cases where a simple function is needed as an argument or return value.</p>
<p>Such stylistic rules are merely guidelines; you can program any way you wish. However, as you write programs, think about the audience of people who might read your program one day. When you can make your program easier to understand, you do those people a favor.</p>
<p>The term <em>lambda</em> is a historical accident resulting from the incompatibility of written mathematical notation and the constraints of early type-setting systems.</p>
<blockquote>
<p>It may seem perverse to use lambda to introduce a procedure&#x2F;function. The notation goes back to Alonzo Church, who in the 1930’s started with a “hat” symbol; he wrote the square function as “ŷ . y × y”. But frustrated typographers moved the hat to the left of the parameter and changed it to a capital lambda: “Λy . y × y”; from there the capital lambda was changed to lowercase, and now we see “λy . y × y” in math books and <code>(lambda (y) (* y y))</code> in Lisp.</p>
<p>—Peter Norvig (norvig.com&#x2F;lispy2.html)</p>
</blockquote>
<p>Despite their unusual etymology, <code>lambda</code> expressions and the corresponding formal language for function application, the <em>lambda calculus</em>, are fundamental computer science concepts shared far beyond the Python programming community. We will revisit this topic when we study the design of interpreters in Chapter 3.</p>
<h3 id="1-6-8-Abstractions-and-First-Class-Functions"><a href="#1-6-8-Abstractions-and-First-Class-Functions" class="headerlink" title="1.6.8  Abstractions and First-Class Functions"></a>1.6.8  Abstractions and First-Class Functions</h3><p>We began this section with the observation that user-defined functions are a crucial abstraction mechanism, because they permit us to express general methods of computing as explicit elements in our programming language. Now we’ve seen how higher-order functions permit us to manipulate these general methods to create further abstractions.</p>
<p>As programmers, we should be alert to opportunities to identify the underlying abstractions in our programs, build upon them, and generalize them to create more powerful abstractions. This is not to say that one should always write programs in the most abstract way possible; expert programmers know how to choose the level of abstraction appropriate to their task. But it is important to be able to think in terms of these abstractions, so that we can be ready to apply them in new contexts. The significance of higher-order functions is that they enable us to represent these abstractions explicitly as elements in our programming language, so that they can be handled just like other computational elements.</p>
<p>In general, programming languages impose restrictions on the ways in which computational elements can be manipulated. Elements with the fewest restrictions are said to have first-class status. Some of the “rights and privileges” of first-class elements are:</p>
<ol>
<li>They may be bound to names.</li>
<li>They may be passed as arguments to functions.</li>
<li>They may be returned as the results of functions.</li>
<li>They may be included in data structures.</li>
</ol>
<p>Python awards functions full first-class status, and the resulting gain in expressive power is enormous.</p>
<h3 id="1-6-9-Function-Decorators"><a href="#1-6-9-Function-Decorators" class="headerlink" title="1.6.9  Function Decorators"></a>1.6.9  Function Decorators</h3><p>Python provides special syntax to apply higher-order functions as part of executing a <code>def</code> statement, called a decorator. Perhaps the most common example is a trace.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">trace</span>(<span class="hljs-params">fn</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapped</span>(<span class="hljs-params">x</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&gt; &#x27;</span>, fn, <span class="hljs-string">&#x27;(&#x27;</span>, x, <span class="hljs-string">&#x27;)&#x27;</span>)<br>            <span class="hljs-keyword">return</span> fn(x)<br>        <span class="hljs-keyword">return</span> wrapped<br><span class="hljs-meta">&gt;&gt;&gt; </span>@trace<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">triple</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span> * x<br><span class="hljs-meta">&gt;&gt;&gt; </span>triple(<span class="hljs-number">12</span>)<br>-&gt;  &lt;function triple at <span class="hljs-number">0x102a39848</span>&gt; ( <span class="hljs-number">12</span> )<br><span class="hljs-number">36</span><br></code></pre></td></tr></table></figure>

<p>In this example, A higher-order function <code>trace</code> is defined, which returns a function that precedes a call to its argument with a <code>print</code> statement that outputs the argument. The <code>def</code> statement for <code>triple</code> has an annotation, <code>@trace</code>, which affects the execution rule for <code>def</code>. As usual, the function <code>triple</code> is created. However, the name <code>triple</code> is not bound to this function. Instead, the name <code>triple</code> is bound to the returned function value of calling <code>trace</code> on the newly defined <code>triple</code> function. In code, this decorator is equivalent to:</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">triple</span>(<span class="hljs-params">x</span>):</span><br>        return 3 * x<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">triple = trace(triple)</span><br></code></pre></td></tr></table></figure>

<p>In the projects associated with this text, decorators are used for tracing, as well as selecting which functions to call when a program is run from the command line.</p>
<p><strong>Extra for experts.</strong> The decorator symbol <code>@</code> may also be followed by a call expression. The expression following <code>@</code> is evaluated first (just as the name <code>trace</code> was evaluated above), the <code>def</code> statement second, and finally the result of evaluating the decorator expression is applied to the newly defined function, and the result is bound to the name in the <code>def</code> statement. A <a target="_blank" rel="noopener" href="http://programmingbits.pythonblogs.com/27_programmingbits/archive/50_function_decorators.html">short tutorial on decorators</a> by Ariel Ortiz gives further examples for interested students.</p>
<h2 id="1-7-Recursive-Functions"><a href="#1-7-Recursive-Functions" class="headerlink" title="1.7  Recursive Functions"></a>1.7  Recursive Functions</h2><p>A function is called <em>recursive</em> if the body of the function calls the function itself, either directly or indirectly. That is, the process of executing the body of a recursive function may in turn require applying that function again. Recursive functions do not use any special syntax in Python, but they do require some effort to understand and create.</p>
<p>We’ll begin with an example problem: write a function that sums the digits of a natural number. When designing recursive functions, we look for ways in which a problem can be broken down into simpler problems. In this case, the operators <code>%</code> and <code>//</code> can be used to separate a number into two parts: its last digit and all but its last digit.</p>
<figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">18117</span> % <span class="hljs-number">10</span></span><br>7<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-number">18117</span> // <span class="hljs-number">10</span></span><br>1811<br></code></pre></td></tr></table></figure>

<p>The sum of the digits of 18117 is <code>1+8+1+1+7 = 18</code>. Just as we can separate the number, we can separate this sum into the last digit, 7, and the sum of all but the last digit, <code>1+8+1+1 = 11</code>. This separation gives us an algorithm: to sum the digits of a number <code>n</code>, add its last digit <code>n % 10</code> to the sum of the digits of <code>n // 10</code>. There’s one special case: if a number has only one digit, then the sum of its digits is itself. This algorithm can be implemented as a recursive function.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum_digits</span>(<span class="hljs-params">n</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Return the sum of the digits of positive integer n.&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">10</span>:<br>            <span class="hljs-keyword">return</span> n<br>        <span class="hljs-keyword">else</span>:<br>            all_but_last, last = n // <span class="hljs-number">10</span>, n % <span class="hljs-number">10</span><br>            <span class="hljs-keyword">return</span> sum_digits(all_but_last) + last<br></code></pre></td></tr></table></figure>

<p>This definition of <code>sum_digits</code> is both complete and correct, even though the <code>sum_digits</code> function is called within its own body. The problem of summing the digits of a number is broken down into two steps: summing all but the last digit, then adding the last digit. Both of these steps are simpler than the original problem. The function is recursive because the first step is the same kind of problem as the original problem. That is, <code>sum_digits</code> is exactly the function we need in order to implement <code>sum_digits</code>.</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs isbl">&gt;&gt;&gt; <span class="hljs-function"><span class="hljs-title">sum_digits</span>(<span class="hljs-number">9</span>)</span><br><span class="hljs-number">9</span><br>&gt;&gt;&gt; <span class="hljs-function"><span class="hljs-title">sum_digits</span>(<span class="hljs-number">18117</span>)</span><br><span class="hljs-number">18</span><br>&gt;&gt;&gt; <span class="hljs-function"><span class="hljs-title">sum_digits</span>(<span class="hljs-number">9437184</span>)</span><br><span class="hljs-number">36</span><br>&gt;&gt;&gt; <span class="hljs-function"><span class="hljs-title">sum_digits</span>(<span class="hljs-number">11408855402054064613470328848384</span>)</span><br><span class="hljs-number">126</span><br></code></pre></td></tr></table></figure>

<p>We can understand precisely how this recursive function applies successfully using our environment model of computation. No new rules are required.</p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191845912.png" srcset="/img/loading.gif" lazyload></p>
<p>When the <code>def</code> statement is executed, the name <code>sum_digits</code> is bound to a new function, but the body of that function is not yet executed. Therefore, the circular nature of <code>sum_digits</code> is not a problem yet. Then, <code>sum_digits</code> is called on 738:</p>
<ol>
<li><p>A local frame for <code>sum_digits</code> with <code>n</code> bound to 738 is created, and the body of <code>sum_digits</code> is executed in the environment that starts with that frame.</p>
</li>
<li><p>Since 738 is not less than 10, the assignment statement on line 4 is executed, splitting 738 into 73 and 8.</p>
</li>
<li><p>In the following return statement, <code>sum_digits</code> is called on 73, the value of <code>all_but_last</code> in the current environment.</p>
</li>
<li><p>Another local frame for <code>sum_digits</code> is created, this time with <code>n</code> bound to 73. The body of <code>sum_digits</code> is again executed in the new environment that starts with this frame.</p>
</li>
<li><p>Since 73 is also not less than 10, 73 is split into 7 and 3 and <code>sum_digits</code> is called on 7, the value of <code>all_but_last</code> evaluated in this frame.</p>
</li>
<li><p>A third local frame for <code>sum_digits</code> is created, with <code>n</code> bound to 7.</p>
</li>
<li><p>In the environment starting with this frame, it is true that <code>n &lt; 10</code>, and therefore 7 is returned.</p>
</li>
<li><p>In the second local frame, this return value 7 is summed with 3, the value of <code>last</code>, to return 10.</p>
</li>
<li><p>In the first local frame, this return value 10 is summed with 8, the value of <code>last</code>, to return 18.</p>
</li>
</ol>
<p>This recursive function applies correctly, despite its circular character, because it is applied twice, but with a different argument each time. Moreover, the second application was a simpler instance of the digit summing problem than the first. Generate the environment diagram for the call <code>sum_digits(18117)</code> to see that each successive call to <code>sum_digits</code> takes a smaller argument than the last, until eventually a single-digit input is reached.</p>
<p>This example also illustrates how functions with simple bodies can evolve complex computational processes by using recursion.</p>
<h3 id="1-7-1-The-Anatomy-of-Recursive-Functions"><a href="#1-7-1-The-Anatomy-of-Recursive-Functions" class="headerlink" title="1.7.1  The Anatomy of Recursive Functions"></a>1.7.1  The Anatomy of Recursive Functions</h3><p>A common pattern can be found in the body of many recursive functions. The body begins with a <em>base case</em>, a conditional statement that defines the behavior of the function for the inputs that are simplest to process. In the case of <code>sum_digits</code>, the base case is any single-digit argument, and we simply return that argument. Some recursive functions will have multiple base cases.</p>
<p>The base cases are then followed by one or more <em>recursive calls</em>. Recursive calls always have a certain character: they simplify the original problem. Recursive functions express computation by simplifying problems incrementally. For example, summing the digits of 7 is simpler than summing the digits of 73, which in turn is simpler than summing the digits of 738. For each subsequent call, there is less work left to be done.</p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191846494.png" srcset="/img/loading.gif" lazyload></p>
<p>A natural implementation using a <code>while</code> statement accumulates the total by multiplying together each positive integer up to <code>n</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">fact_iter</span>(<span class="hljs-params">n</span>):<br>        total, k = <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> k &lt;= n:<br>            total, k = total * k, k + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> total<br><span class="hljs-meta">&gt;&gt;&gt; </span>fact_iter(<span class="hljs-number">4</span>)<br><span class="hljs-number">24</span><br></code></pre></td></tr></table></figure>

<p>On the other hand, a recursive implementation of factorial can express <code>fact(n)</code> in terms of <code>fact(n-1)</code>, a simpler problem. The base case of the recursion is the simplest form of the problem: <code>fact(1)</code> is 1.</p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191846347.png" srcset="/img/loading.gif" lazyload></p>
<p>These two factorial functions differ conceptually. The iterative function constructs the result from the base case of 1 to the final total by successively multiplying in each term. The recursive function, on the other hand, constructs the result directly from the final term, <code>n</code>, and the result of the simpler problem, <code>fact(n-1)</code>.</p>
<p>As the recursion “unwinds” through successive applications of the <em>fact</em> function to simpler and simpler problem instances, the result is eventually built starting from the base case. The recursion ends by passing the argument 1 to <code>fact</code>; the result of each call depends on the next until the base case is reached.</p>
<p>The correctness of this recursive function is easy to verify from the standard definition of the mathematical function for factorial:</p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191846534.png" srcset="/img/loading.gif" lazyload></p>
<p>While we can unwind the recursion using our model of computation, it is often clearer to think about recursive calls as functional abstractions. That is, we should not care about how <code>fact(n-1)</code> is implemented in the body of <code>fact</code>; we should simply trust that it computes the factorial of <code>n-1</code>. Treating a recursive call as a functional abstraction has been called a <em>recursive leap of faith</em>. We define a function in terms of itself, but simply trust that the simpler cases will work correctly when verifying the correctness of the function. In this example, we trust that <code>fact(n-1)</code> will correctly compute <code>(n-1)!</code>; we must only check that <code>n!</code> is computed correctly if this assumption holds. In this way, verifying the correctness of a recursive function is a form of proof by induction.</p>
<p>The functions <em>fact_iter</em> and <em>fact</em> also differ because the former must introduce two additional names, <code>total</code> and <code>k</code>, that are not required in the recursive implementation. In general, iterative functions must maintain some local state that changes throughout the course of computation. At any point in the iteration, that state characterizes the result of completed work and the amount of work remaining. For example, when <code>k</code> is 3 and total is 2, there are still two terms remaining to be processed, 3 and 4. On the other hand, <em>fact</em> is characterized by its single argument <code>n</code>. The state of the computation is entirely contained within the structure of the environment, which has return values that take the role of <code>total</code>, and binds <code>n</code> to different values in different frames rather than explicitly tracking <code>k</code>.</p>
<p>Recursive functions leverage the rules of evaluating call expressions to bind names to values, often avoiding the nuisance of correctly assigning local names during iteration. For this reason, recursive functions can be easier to define correctly. However, learning to recognize the computational processes evolved by recursive functions certainly requires practice.</p>
<h3 id="1-7-2-Mutual-Recursion"><a href="#1-7-2-Mutual-Recursion" class="headerlink" title="1.7.2  Mutual Recursion"></a>1.7.2  Mutual Recursion</h3><p>When a recursive procedure is divided among two functions that call each other, the functions are said to be <em>mutually recursive</em>. As an example, consider the following definition of even and odd for non-negative integers:</p>
<ul>
<li>a number is even if it is one more than an odd number</li>
<li>a number is odd if it is one more than an even number</li>
<li>0 is even</li>
</ul>
<p>Using this definition, we can implement mutually recursive functions to determine whether a number is even or odd:</p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191847202.png" srcset="/img/loading.gif" lazyload></p>
<p>Mutually recursive functions can be turned into a single recursive function by breaking the abstraction boundary between the two functions. In this example, the body of <code>is_odd</code> can be incorporated into that of <code>is_even</code>, making sure to replace <code>n</code> with <code>n-1</code> in the body of <code>is_odd</code> to reflect the argument passed into it:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_even</span>(<span class="hljs-params">n</span>):<br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> (n-<span class="hljs-number">1</span>) == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> is_even((n-<span class="hljs-number">1</span>)-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>

<p>As such, mutual recursion is no more mysterious or powerful than simple recursion, and it provides a mechanism for maintaining abstraction within a complicated recursive program.</p>
<h3 id="1-7-3-Printing-in-Recursive-Functions"><a href="#1-7-3-Printing-in-Recursive-Functions" class="headerlink" title="1.7.3  Printing in Recursive Functions"></a>1.7.3  Printing in Recursive Functions</h3><p>The computational process evolved by a recursive function can often be visualized using calls to <code>print</code>. As an example, we will implement a function <code>cascade</code> that prints all prefixes of a number from largest to smallest to largest.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">cascade</span>(<span class="hljs-params">n</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Print a cascade of prefixes of n.&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">10</span>:<br>            <span class="hljs-built_in">print</span>(n)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(n)<br>            cascade(n//<span class="hljs-number">10</span>)<br>            <span class="hljs-built_in">print</span>(n)<br><span class="hljs-meta">&gt;&gt;&gt; </span>cascade(<span class="hljs-number">2013</span>)<br><span class="hljs-number">2013</span><br><span class="hljs-number">201</span><br><span class="hljs-number">20</span><br><span class="hljs-number">2</span><br><span class="hljs-number">20</span><br><span class="hljs-number">201</span><br><span class="hljs-number">2013</span><br></code></pre></td></tr></table></figure>

<p>In this recursive function, the base case is a single-digit number, which is printed. Otherwise, a recursive call is placed between two calls to <code>print</code>.</p>
<p>It is not a rigid requirement that base cases be expressed before recursive calls. In fact, this function can be expressed more compactly by observing that <code>print(n)</code> is repeated in both clauses of the conditional statement, and therefore can precede it.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">cascade</span>(<span class="hljs-params">n</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Print a cascade of prefixes of n.&quot;&quot;&quot;</span><br>        <span class="hljs-built_in">print</span>(n)<br>        <span class="hljs-keyword">if</span> n &gt;= <span class="hljs-number">10</span>:<br>            cascade(n//<span class="hljs-number">10</span>)<br>            <span class="hljs-built_in">print</span>(n)<br></code></pre></td></tr></table></figure>

<p>As another example of mutual recursion, consider a two-player game in which there are <code>n</code> initial pebbles on a table. The players take turns, removing either one or two pebbles from the table, and the player who removes the final pebble wins. Suppose that Alice and Bob play this game, each using a simple strategy:</p>
<ul>
<li>Alice always removes a single pebble</li>
<li>Bob removes two pebbles if an even number of pebbles is on the table, and one otherwise</li>
</ul>
<p>Given <code>n</code> initial pebbles and Alice starting, who wins the game?</p>
<p>A natural decomposition of this problem is to encapsulate each strategy in its own function. This allows us to modify one strategy without affecting the other, maintaining the abstraction barrier between the two. In order to incorporate the turn-by-turn nature of the game, these two functions call each other at the end of each turn.</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs isbl">&gt;&gt;&gt; <span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">play_alice</span>(<span class="hljs-variable">n</span>):</span><br><span class="hljs-function">        <span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">n</span> == <span class="hljs-number">0</span>:</span><br><span class="hljs-function">            <span class="hljs-title">print</span>(<span class="hljs-string">&quot;Bob wins!&quot;</span>)</span><br>        <span class="hljs-variable"><span class="hljs-keyword">else</span></span>:<br>            <span class="hljs-function"><span class="hljs-title">play_bob</span>(<span class="hljs-variable">n</span>-<span class="hljs-number">1</span>)</span><br>&gt;&gt;&gt; <span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">play_bob</span>(<span class="hljs-variable">n</span>):</span><br><span class="hljs-function">        <span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">n</span> == <span class="hljs-number">0</span>:</span><br><span class="hljs-function">            <span class="hljs-title">print</span>(<span class="hljs-string">&quot;Alice wins!&quot;</span>)</span><br>        <span class="hljs-variable">elif</span> <span class="hljs-function"><span class="hljs-title">is_even</span>(<span class="hljs-variable">n</span>):</span><br><span class="hljs-function">            <span class="hljs-title">play_alice</span>(<span class="hljs-variable">n</span>-<span class="hljs-number">2</span>)</span><br>        <span class="hljs-variable"><span class="hljs-keyword">else</span></span>:<br>            <span class="hljs-function"><span class="hljs-title">play_alice</span>(<span class="hljs-variable">n</span>-<span class="hljs-number">1</span>)</span><br>&gt;&gt;&gt; <span class="hljs-function"><span class="hljs-title">play_alice</span>(<span class="hljs-number">20</span>)</span><br><span class="hljs-variable">Bob</span> <span class="hljs-variable">wins</span><span class="hljs-variable">!</span><br></code></pre></td></tr></table></figure>

<p>In <code>play_bob</code>, we see that multiple recursive calls may appear in the body of a function. However, in this example, each call to <code>play_bob</code> calls <code>play_alice</code> at most once. In the next section, we consider what happens when a single function call makes multiple direct recursive calls.</p>
<h3 id="1-7-4-Tree-Recursion"><a href="#1-7-4-Tree-Recursion" class="headerlink" title="1.7.4  Tree Recursion"></a>1.7.4  Tree Recursion</h3><p>Another common pattern of computation is called tree recursion, in which a function calls itself more than once. As an example, consider computing the sequence of Fibonacci numbers, in which each number is the sum of the preceding two.</p>
<p><img src="https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202307191848392.png" srcset="/img/loading.gif" lazyload></p>
<p>This recursive definition is tremendously appealing relative to our previous attempts: it exactly mirrors the familiar definition of Fibonacci numbers. A function with multiple recursive calls is said to be <em>tree recursive</em> because each call branches into multiple smaller calls, each of which branches into yet smaller calls, just as the branches of a tree become smaller but more numerous as they extend from the trunk.</p>
<p>We were already able to define a function to compute Fibonacci numbers without tree recursion. In fact, our previous attempts were more efficient, a topic discussed later in the text. Next, we consider a problem for which the tree recursive solution is substantially simpler than any iterative alternative.</p>
<h3 id="1-7-5-Example-Partitions"><a href="#1-7-5-Example-Partitions" class="headerlink" title="1.7.5  Example: Partitions"></a>1.7.5  Example: Partitions</h3><p>The number of partitions of a positive integer <code>n</code>, using parts up to size <code>m</code>, is the number of ways in which <code>n</code> can be expressed as the sum of positive integer parts up to <code>m</code> in increasing order. For example, the number of partitions of 6 using parts up to 4 is 9.</p>
<ol>
<li><code>6 = 2 + 4</code></li>
<li><code>6 = 1 + 1 + 4</code></li>
<li><code>6 = 3 + 3</code></li>
<li><code>6 = 1 + 2 + 3</code></li>
<li><code>6 = 1 + 1 + 1 + 3</code></li>
<li><code>6 = 2 + 2 + 2</code></li>
<li><code>6 = 1 + 1 + 2 + 2</code></li>
<li><code>6 = 1 + 1 + 1 + 1 + 2</code></li>
<li><code>6 = 1 + 1 + 1 + 1 + 1 + 1</code></li>
</ol>
<p>We will define a function <code>count_partitions(n, m)</code> that returns the number of different partitions of <code>n</code> using parts up to <code>m</code>. This function has a simple solution as a tree-recursive function, based on the following observation:</p>
<p>The number of ways to partition <code>n</code> using integers up to <code>m</code> equals</p>
<ol>
<li>the number of ways to partition <code>n-m</code> using integers up to <code>m</code>, and</li>
<li>the number of ways to partition <code>n</code> using integers up to <code>m-1</code>.</li>
</ol>
<p>To see why this is true, observe that all the ways of partitioning <code>n</code> can be divided into two groups: those that include at least one <code>m</code> and those that do not. Moreover, each partition in the first group is a partition of <code>n-m</code>, followed by <code>m</code> added at the end. In the example above, the first two partitions contain 4, and the rest do not.</p>
<p>Therefore, we can recursively reduce the problem of partitioning <code>n</code> using integers up to <code>m</code> into two simpler problems: (1) partition a smaller number <code>n-m</code>, and (2) partition with smaller components up to <code>m-1</code>.</p>
<p>To complete the implementation, we need to specify the following base cases:</p>
<ol>
<li>There is one way to partition 0: include no parts.</li>
<li>There are 0 ways to partition a negative <code>n</code>.</li>
<li>There are 0 ways to partition any <code>n</code> greater than 0 using parts of size 0 or less.</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">count_partitions</span>(<span class="hljs-params">n, m</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Count the ways to partition n using parts up to m.&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> n &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">elif</span> m == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> count_partitions(n-m, m) + count_partitions(n, m-<span class="hljs-number">1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>count_partitions(<span class="hljs-number">6</span>, <span class="hljs-number">4</span>)<br><span class="hljs-number">9</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>count_partitions(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>)<br><span class="hljs-number">7</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>count_partitions(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>)<br><span class="hljs-number">42</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>count_partitions(<span class="hljs-number">15</span>, <span class="hljs-number">15</span>)<br><span class="hljs-number">176</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>count_partitions(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>)<br><span class="hljs-number">627</span><br></code></pre></td></tr></table></figure>

<p>We can think of a tree-recursive function as exploring different possibilities. In this case, we explore the possibility that we use a part of size <code>m</code> and the possibility that we do not. The first and second recursive calls correspond to these possibilities.</p>
<p>Implementing this function without recursion would be substantially more involved. Interested readers are encouraged to try.</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Major/" class="category-chain-item">Major</a>
  
  
    <span>></span>
    
  <a href="/categories/Major/CS61A/" class="category-chain-item">CS61A</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/CS61A/">#CS61A</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>CS61A-Reference</div>
      <div>https://www.0co.dev/CS61A-Reference/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Konrad Gerrens</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年7月19日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/CS61A-lab03-Q5/" title="CS61A-lab03_Q5">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CS61A-lab03_Q5</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/ShanHe-University-Review/" title="虚拟的山河大学与真实的教育困境">
                        <span class="hidden-mobile">虚拟的山河大学与真实的教育困境</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="twikoo"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/twikoo/1.6.8/twikoo.all.min.js', function() {
        var options = Object.assign(
          {"envId":"https://cmt.0co.dev","region":"ap-shanghai","path":"window.location.pathname"},
          {
            el: '#twikoo',
            path: 'window.location.pathname',
            onCommentLoaded: function() {
              var imgSelector = '#twikoo .tk-content img:not(.tk-owo-emotion)';
              Fluid.plugins.imageCaption(imgSelector);
              Fluid.plugins.fancyBox(imgSelector);
            }
          }
        )
        twikoo.init(options)
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <!-- <div class="footer-inner"> -->
<div class="footer-inner" style="font-size: 0.85rem;">
  <!--yiyan footer-->
  
    <div class="footer-content">
       <div class="statistics"> <a target="_blank" rel="noopener" href="https://developer.hitokoto.cn/" id="hitokoto_text"><span style="color: #DDD;"  id="hitokoto"></span></a> <script src="https://v1.hitokoto.cn/?encode=js&select=%23hitokoto" defer></script> </div>
    </div>
  
  <!-- -->
  
    <div class="footer-content">
       Build by <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> with <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid Theme</span></a> <br/> © 2023 Konrad Gerrens <div style="font-size: 0.85rem"> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  

  
  
</div>
<script>
  (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();
  </script>
  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
